<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Newres Al Haider</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css"> -->
  <link href="https:&#x2F;&#x2F;www.newresalhaider.com/style.css" rel="stylesheet">
  <script type="text/javascript" src="https://www.newresalhaider.com/scripts/menu.js"></script>
    <meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@newresa">
<meta name="twitter:creator" content="@newresa">


<meta name="twitter:title" content="Darmok in core.logic">
<meta name="title" property="og:title" content="Darmok in core.logic" />


<meta name="twitter:description" content="A tutorial to logic programming using miniKanren and core.logic by representing and using the allegory based Tamarian language from the Start Trek Next-Generation Episode Darmok.
">
<meta name="description" property="og:description" content="A tutorial to logic programming using miniKanren and core.logic by representing and using the allegory based Tamarian language from the Start Trek Next-Generation Episode Darmok.
" />


<meta name="author" content="Newres Al Haider" />
<meta property="article:author" content="Newres Al Haider">
<meta property="og:type" content="article" />

<meta property="article:published_time" content="2020-02-02">


    
        <meta property="article:tag" content="AI">
    
        <meta property="article:tag" content="logic programming">
    
        <meta property="article:tag" content="core.logic">
    
        <meta property="article:tag" content="kanren">
    
        <meta property="article:tag" content="clojure">
    
        <meta property="article:tag" content="Star Trek">
    


    <meta property="article:modified_time" content="2019-02-02">



<meta property="twitter:image" content="https://www.newresalhaider.com/post/darmok-core-logic/featured.jpg">
<meta property="og:image" content="https://www.newresalhaider.com/post/darmok-core-logic/featured.jpg" />


</head>

<body class="has-navbar-fixed-top">

    <nav class="navbar is-primary is-fixed-top" role="navigation" aria-label="main navigation">
    <div class="navbar-brand">
        <a class="navbar-item" href="/">
            <h1 class="title is-3">
                Newres Al Haider
            </h1>
        </a>
        <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false" data-target="NavbarMenu">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
    </div>
    <div id="NavbarMenu" class="navbar-menu">
        <div class="navbar-start">
        </div>
        <div class="navbar-end">
            <a class="navbar-item" href="/">
                <h2 class="subtitle is-5">
                    Home
                </h2>
            </a>
            <a class="navbar-item" href="/post/">
                <h2 class="subtitle is-5">
                    Posts
                </h2>
            </a>
            <a class="navbar-item" href="/project/">
                <h2 class="subtitle is-5">
                    Projects
                </h2>
            </a>
            <a class="navbar-item" href="/publication/">
                <h2 class="subtitle is-5">
                    Publications
                </h2>
            </a>
        </div>
    </div>
</nav>
  <section class="section">
    <div class="container">
      

<h1 class="title">
    Darmok in core.logic
</h1>
<p class="subtitle"><strong>2020-02-02</strong></p>
<p>One of the greatest Star Trek episodes is titled <a href="https://en.wikipedia.org/wiki/Darmok">Darmok</a> in <a href="https://en.wikipedia.org/wiki/Star_Trek:_The_Next_Generation">Star Trek: The Next Generation</a>.  It has the hallmarks of a great Star Trek: TNG episode: a first contact between two civilizations and a dilemma that is not solved by violence but by thinking and understanding.</p>
<p>One of the nicest logic programming languages is <a href="http://minikanren.org/">miniKanren</a>. This is due to the fact that it is a small, relatively easy to understand <a href="https://en.wikipedia.org/wiki/Logic_programming">Logic Programming (LP)</a> language and has implementations in many programming languages. This later feature allows for logic programming features to be used in many different environments, as a logic programming <a href="https://en.wikipedia.org/wiki/Domain-specific_language">Domain-Specific language (DSL)</a>. </p>
<p>A popular implementation of miniKanren is the <a href="https://github.com/clojure/core.logic">core.logic</a> library of the <a href="https://clojure.org/">Clojure</a> programming language. In this article we aim to introduce miniKanren/core.logic by encoding story elements of the Darmok episode of Star Trek: TNG (some spoilers for the episode will follow). </p>
<p>The episode is based around the fact that the Federation and the Tamarian people aim to establish successful first contact with each other. From the Federation, the crew of the starship Enterprise are sent to the planet El-Adrel where a Tamarian ship awaits them. Unfortunately attempts at communication fail from both sides and lead to some dangerous situations. The difficulty of communication arises from the fact that Tamarians communicate exclusively through allegory. This means that it is not enough to just decipher the words and grammar used in the Tamarian language, but the crew of the Enterprise must also understand the myths and historical events to which these allegories refer to. Within the episode multiple allegories are used by the Tamarians, such as with the phrase &quot;Darmok and Jalad at Tanagra&quot;, that utterly baffle the crew at first. However due to shared dangers and cooperation by the captain of the Enterprise, Picard, and the captain of the Tamarian ship, Darmok, they start to understand each other. In the end a successful first contact is made. This is captured by the newly coined allegory for first contact in the Tamarian language: &quot;Picard and Dathon at El-Adrel&quot;.</p>
<p>In this article we will use core.logic to write a logic program to represent the allegories used in the Darmok episode and to generate templates of the Darmok story through a sequence of allegories. A logic program is a bit different than the programs most people are used to. Instead of giving precise instructions to the computer one instead writes a goal, or a group of goals, that provide some logical restrictions on what one intends to achieve. With these goals the logic programming system can find the right answers. Note that the source for the code used this article can be found <a href="https://github.com/newres/darmok-core-logic">here</a> in case you want to experiment along while reading this article.</p>
<p>Let's start off with a small logic program that can translate the Tamarian allegory that represents cooperation, the phrase &quot;Darmok and Jalad at Tanagra&quot;. We aim to translate this allegory to an equivalent allegory based on a human myth, as well as the English translation for it: &quot;cooperation&quot;. </p>
<p>In order to do this we give the Clojure definition of this goal as a logic program, then explain each element of it and how to use it.</p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>(</span><span style="color:#b48ead;">defn </span><span style="color:#8fa1b3;">cooperation </span><span>[tam hum eng]
</span><span>  (</span><span style="color:#bf616a;">l/conde </span><span>[(</span><span style="color:#bf616a;">l/== </span><span>[tam] [&quot;</span><span style="color:#a3be8c;">Darmok and Jalad at Tanagra.</span><span>&quot;])
</span><span>            (</span><span style="color:#bf616a;">l/== </span><span>[hum] [&quot;</span><span style="color:#a3be8c;">Gilgamesh and Ekidu at Uruk.</span><span>&quot;])
</span><span>            (</span><span style="color:#bf616a;">l/== </span><span>[eng] [&quot;</span><span style="color:#a3be8c;">cooperation</span><span>&quot;])]))
</span></code></pre>
<p>First lets decipher the above definition. For people, unfamiliar with Clojure, the form <code>(defn cooperation [tam hum eng] ... )</code> defines a function named <code>cooperation</code> with the parameters <code>tam hum eng</code>. The part with <code>(l/conde ... )</code> is a shorthand for <code>(core.logic/conde ... )</code>; we will use <code>l</code> as the abbreviation for the <code>core.logic</code> namespace in the rest of this article. This <code>l/conde</code> part functions as a way to connect various goals together. It creates a disjunction (elements separated by OR) of separate vectors of goals which it considers as conjunction (elements separated by AND). For people a bit familiar with boolean logic this a way to write a <a href="https://en.wikipedia.org/wiki/Disjunctive_normal_form">Disjunctive Normal Form</a>. To give a very simplified example the form <code>(l/conde [A B] [C] )</code> with the goals <code>A, B, C</code> can be seen as a way to find the case where <code>(A 'AND' B) 'OR' C</code> holds. In the previous example <code>l/conde</code> is called on a single vector of elements <code>[(l/== [tam] [&quot;Darmok and Jalad at Tanagra.&quot;]) (l/== [hum] [&quot;Gilgamesh and Ekidu at Uruk.&quot;]) (l/== [eng] [&quot;cooperation&quot;])]</code>, meaning that this function wants each of the goals: <code>(l/== [tam] [&quot;Darmok and Jalad at Tanagra.&quot;])</code> AND <code>(l/== [hum] [&quot;Gilgamesh and Ekidu at Uruk.&quot;])</code> AND <code> (l/== [eng] [&quot;cooperation&quot;])</code> fulfilled. </p>
<p>So now we know that this function takes three parameters and wants to ensure that the three goals all have to be met. But what do the goals themselves mean? They all have a similar structure in that they are using the equality in core.logic, <code>l/==</code>, to unify elements. Unification is a core part of a logic programming system and it is used to constrain elements to the same possible values. For the first example <code>(l/== [tam] [&quot;Darmok and Jalad at Tanagra.&quot;])</code>, the unification aims to ensure that the variable <code>tam</code> has the value of the string <code>&quot;Darmok and Jalad at Tanagra.&quot;</code>, which can be seen as the Tamarian phrase for cooperation. The other goals do this unification for the human mythology equivalent: <code>&quot;Gilgamesh and Ekidu at Uruk.&quot;</code> of this allegory, as well for the English word <code>&quot;cooperation&quot;</code>, for the variables <code>hum</code> and <code>eng</code>, respectively.</p>
<p>We have now given an anatomy of this logic program that does unification on phrases relating to cooperation, but how do we use it? For this we need two things: a set of logic variables and a way to tell the system to run the logic program. The function <code>l\run*</code> does exactly that, which for the given set of parameters tries to find all examples where the goals are fulfilled.</p>
<p>So if we evaluate the following code:</p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>(</span><span style="color:#bf616a;">l/run* </span><span>[tam hum eng]
</span><span>        (</span><span style="color:#bf616a;">cooperation</span><span> tam hum eng))
</span></code></pre>
<p>we get the following:</p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>([&quot;</span><span style="color:#a3be8c;">Darmok and Jalad at Tanagra.</span><span>&quot; &quot;</span><span style="color:#a3be8c;">Gilgamesh and Ekidu at Uruk.</span><span>&quot; &quot;</span><span style="color:#a3be8c;">cooperation</span><span>&quot;])
</span></code></pre>
<p>What <code>l\run*</code> is doing is taking a given list of logic variables and tries to list all the possible values these variables can take. Here it only lists a single possible set of values for the variables <code>tam</code>, <code>hum</code> and <code>eng</code>. This should not be surprising as there is only exactly one way each of the variables <code>tam</code>, <code>hum</code>, and <code>eng</code> can be fulfilled by the &quot;cooperation&quot; goal based on the definition we gave above.  The variable <code>tam</code> gets unified with the string value <code>&quot;Darmok and Jalad at Tanagra.&quot;</code>, <code>hum</code> with <code>&quot;Gilgamesh and Ekidu at Uruk.&quot;</code> and <code>eng</code> with <code>&quot;cooperation&quot;</code>.</p>
<p>In the previous case we used only 'fresh' logic variables (variables that have no constraints placed upon their possible values yet), but instead we can also use a specific value in our goal instead. In the following example we only have two variables. Instead of a variable for first parameter used in the cooperation goal we give the string `&quot;Darmok and Jalad at Tanagra.&quot; as follows:</p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>(</span><span style="color:#bf616a;">l/run* </span><span>[hum eng]
</span><span>        (</span><span style="color:#bf616a;">cooperation </span><span>&quot;</span><span style="color:#a3be8c;">Darmok and Jalad at Tanagra.</span><span>&quot; hum eng))
</span></code></pre>
<p>which gives the result:</p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>([&quot;</span><span style="color:#a3be8c;">Gilgamesh and Ekidu at Uruk.</span><span>&quot; &quot;</span><span style="color:#a3be8c;">cooperation</span><span>&quot;])
</span></code></pre>
<p>There are only two variables listed in the answer, as there are only two variables given for <code>l/run*</code> to check in our initial case. Otherwise the answer is exactly what we would expect as there is only one possible way these variables can be bound in our logic program.</p>
<p>Now lets try a run where there are no possible valid answers, giving the word <code>&quot;challenge&quot;</code> as a parameter:</p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>(</span><span style="color:#bf616a;">l/run* </span><span>[tam hum eng]
</span><span>        (</span><span style="color:#bf616a;">cooperation</span><span> tam hum &quot;</span><span style="color:#a3be8c;">challenge</span><span>&quot;))
</span></code></pre>
<p>This returns an empty list of answers: <code>()</code>, as there are no ways to unify the word <code>&quot;challenge&quot;</code> inside the goal of cooperation.</p>
<p>Given we got the basics of logic programs covered, lets expand our example into something more complex.</p>
<p>Instead of one single allegory, we now define five of them based on the various allegories used in the Darmok episode. The functions representing these goals are all named after the English word translation: <code>failure</code>, <code>common-enemy</code>, <code>cooperation</code>, <code>successful-cooperation</code> and <code>successful-first-contact</code>. They all follow the same structure as the <code>cooperation</code> allegory we previously examined in detail. In addition we also define a function for representing any allegory, aptly named <code>allegory</code>. This is a goal that can be fulfilled by any of the allegories named above.</p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>(</span><span style="color:#b48ead;">defn </span><span style="color:#8fa1b3;">failure </span><span>[tam hum eng]
</span><span>  (</span><span style="color:#bf616a;">l/conde </span><span>[(</span><span style="color:#bf616a;">l/== </span><span>[tam] [&quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;])
</span><span>            (</span><span style="color:#bf616a;">l/== </span><span>[hum] [&quot;</span><span style="color:#a3be8c;">Gilgamesh, his plant eaten by a snake.</span><span>&quot;])
</span><span>            (</span><span style="color:#bf616a;">l/== </span><span>[eng] [&quot;</span><span style="color:#a3be8c;">failure</span><span>&quot;])]))
</span><span>
</span><span>(</span><span style="color:#b48ead;">defn </span><span style="color:#8fa1b3;">common-enemy </span><span>[tam hum eng]
</span><span>  (</span><span style="color:#bf616a;">l/conde </span><span>[(</span><span style="color:#bf616a;">l/== </span><span>[tam] [&quot;</span><span style="color:#a3be8c;">Beast at Tanagra.</span><span>&quot;])
</span><span>            (</span><span style="color:#bf616a;">l/== </span><span>[hum] [&quot;</span><span style="color:#a3be8c;">Bull of Heaven.</span><span>&quot;])
</span><span>            (</span><span style="color:#bf616a;">l/== </span><span>[eng] [&quot;</span><span style="color:#a3be8c;">common-enemy</span><span>&quot;])]))
</span><span>
</span><span>(</span><span style="color:#b48ead;">defn </span><span style="color:#8fa1b3;">cooperation </span><span>[tam hum eng]
</span><span>  (</span><span style="color:#bf616a;">l/conde </span><span>[(</span><span style="color:#bf616a;">l/== </span><span>[tam] [&quot;</span><span style="color:#a3be8c;">Darmok and Jalad at Tanagra.</span><span>&quot;])
</span><span>            (</span><span style="color:#bf616a;">l/== </span><span>[hum] [&quot;</span><span style="color:#a3be8c;">Gilgamesh and Ekidu at Uruk.</span><span>&quot;])
</span><span>            (</span><span style="color:#bf616a;">l/== </span><span>[eng] [&quot;</span><span style="color:#a3be8c;">cooperation</span><span>&quot;])]))
</span><span>
</span><span>(</span><span style="color:#b48ead;">defn </span><span style="color:#8fa1b3;">successful-cooperation </span><span>[tam hum eng]
</span><span>  (</span><span style="color:#bf616a;">l/conde </span><span>[(</span><span style="color:#bf616a;">l/== </span><span>[tam] [&quot;</span><span style="color:#a3be8c;">Darmok and Jalad on the ocean.</span><span>&quot;])
</span><span>            (</span><span style="color:#bf616a;">l/== </span><span>[hum] [&quot;</span><span style="color:#a3be8c;">Gilgamesh and Ekidu, after the Bull&#39;s defeat.</span><span>&quot;])
</span><span>            (</span><span style="color:#bf616a;">l/== </span><span>[eng] [&quot;</span><span style="color:#a3be8c;">successful-cooperation</span><span>&quot;])]))
</span><span>
</span><span>(</span><span style="color:#b48ead;">defn </span><span style="color:#8fa1b3;">successful-first-contact </span><span>[tam hum eng]
</span><span>  (</span><span style="color:#bf616a;">l/conde </span><span>[(</span><span style="color:#bf616a;">l/== </span><span>[tam] [&quot;</span><span style="color:#a3be8c;">Picard and Dathon at El-Adrel.</span><span>&quot;])
</span><span>            (</span><span style="color:#bf616a;">l/== </span><span>[hum] [&quot;</span><span style="color:#a3be8c;">Picard and Dathon at El-Adrel.</span><span>&quot;])
</span><span>            (</span><span style="color:#bf616a;">l/== </span><span>[eng] [&quot;</span><span style="color:#a3be8c;">successful-first-contact</span><span>&quot;])]))
</span><span>
</span><span>(</span><span style="color:#b48ead;">defn </span><span style="color:#8fa1b3;">allegory </span><span>[tam hum eng]
</span><span>  (</span><span style="color:#bf616a;">l/conde </span><span>[(</span><span style="color:#bf616a;">failure</span><span> tam hum eng)]
</span><span>           [(</span><span style="color:#bf616a;">common-enemy</span><span> tam hum eng)]
</span><span>           [(</span><span style="color:#bf616a;">cooperation</span><span> tam hum eng)]
</span><span>           [(</span><span style="color:#bf616a;">successful-cooperation</span><span> tam hum eng)]
</span><span>           [(</span><span style="color:#bf616a;">successful-first-contact</span><span> tam hum eng)]))
</span></code></pre>
<p>There should not be any very surprising elements in this part, but we give two quick observations before continuing. </p>
<p>First, the human equivalent for Tamarian allegories are based on the Gilgamesh story, which is also explicitly mentioned in the episode, that provides a way for captain Picard to connect with the Tamarian captain Dathon. The only exception to this is <code>&quot;Picard and Dathon at El-Adrel.&quot;</code> which is an allegory coined at the end of the episode as a term for first contact between cultures. It seems fitting to use this as an allegory from a human perspective as well. </p>
<p>Second, to reiterate how <code>l/conde</code> works with choices, we remark that each of the named allegories in the <code>allegory</code> function are in their own vector (indicated by each goal inside their own <code>[]</code> brackets). This indicates that any of <code>failure</code>, <code>common-enemy</code>, <code>cooperation</code>, <code>successful-cooperation</code> or <code>successful-first-contact</code> can fulfill the goal of <code>allegory</code>. </p>
<p>We can test this later notion by running a short logic program for finding all possible allegories:</p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>(</span><span style="color:#bf616a;">l/run* </span><span>[tam hum eng]
</span><span>        (</span><span style="color:#bf616a;">allegory</span><span> tam hum eng))
</span></code></pre>
<p>which returns:</p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>([&quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Gilgamesh, his plant eaten by a snake.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">failure</span><span>&quot;]
</span><span> [&quot;</span><span style="color:#a3be8c;">Beast at Tanagra.</span><span>&quot; &quot;</span><span style="color:#a3be8c;">Bull of Heaven.</span><span>&quot; &quot;</span><span style="color:#a3be8c;">common-enemy</span><span>&quot;]
</span><span> [&quot;</span><span style="color:#a3be8c;">Darmok and Jalad at Tanagra.</span><span>&quot; &quot;</span><span style="color:#a3be8c;">Gilgamesh and Ekidu at Uruk.</span><span>&quot; &quot;</span><span style="color:#a3be8c;">cooperation</span><span>&quot;]
</span><span> [&quot;</span><span style="color:#a3be8c;">Darmok and Jalad on the ocean.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Gilgamesh and Ekidu, after the Bull&#39;s defeat.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">successful-cooperation</span><span>&quot;]
</span><span> [&quot;</span><span style="color:#a3be8c;">Picard and Dathon at El-Adrel.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Picard and Dathon at El-Adrel.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">successful-first-contact</span><span>&quot;])
</span></code></pre>
<p>This shows five possible answers because, as mentioned, any of the above allegories can fulfill the given goal.</p>
<p>By default <code>l/run*</code> will list all possible answers for a given logic program, which is a very powerful feature for exhaustively searching for all the solutions to a given problem. However this list can be large, and even infinite! In such scenarios there is a way to limit the answers to a certain number when searching by using <code>l/run</code> (note the lack of the <code>*</code> character) directly followed by the number of answers we want returned. </p>
<p>For example, the call:</p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>(</span><span style="color:#bf616a;">l/run </span><span style="color:#d08770;">2 </span><span>[tam hum eng]
</span><span>       (</span><span style="color:#bf616a;">allegory</span><span> tam hum eng))
</span></code></pre>
<p>will return only two possible answers: </p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>([&quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Gilgamesh, his plant eaten by a snake.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">failure</span><span>&quot;]
</span><span> [&quot;</span><span style="color:#a3be8c;">Beast at Tanagra.</span><span>&quot; &quot;</span><span style="color:#a3be8c;">Bull of Heaven.</span><span>&quot; &quot;</span><span style="color:#a3be8c;">common-enemy</span><span>&quot;])
</span></code></pre>
<p>Now as we are getting a bit more familiar with the allegories in this example, we do not want to write out all three versions of each allegory each time. We can do this by defining a new goal <code>allegory-short</code> that succeeds for any phrase that identifies one of the five allegories:</p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>(</span><span style="color:#b48ead;">defn </span><span style="color:#8fa1b3;">allegory-tam </span><span>[tam]
</span><span>  (</span><span style="color:#bf616a;">l/fresh </span><span>[x y]
</span><span>           (</span><span style="color:#bf616a;">allegory</span><span> tam x y)))
</span><span>
</span><span>(</span><span style="color:#b48ead;">defn </span><span style="color:#8fa1b3;">allegory-hum </span><span>[hum]
</span><span>  (</span><span style="color:#bf616a;">l/fresh </span><span>[x y]
</span><span>           (</span><span style="color:#bf616a;">allegory</span><span> x hum y)))
</span><span>
</span><span>(</span><span style="color:#b48ead;">defn </span><span style="color:#8fa1b3;">allegory-eng </span><span>[eng]
</span><span>  (</span><span style="color:#bf616a;">l/fresh </span><span>[x y]
</span><span>           (</span><span style="color:#bf616a;">allegory</span><span> x y eng)))
</span><span>
</span><span>(</span><span style="color:#b48ead;">defn </span><span style="color:#8fa1b3;">allegory-short </span><span>[x]
</span><span>  (</span><span style="color:#bf616a;">l/conde </span><span>[(</span><span style="color:#bf616a;">allegory-tam</span><span> x)]
</span><span>           [(</span><span style="color:#bf616a;">allegory-hum</span><span> x)]
</span><span>           [(</span><span style="color:#bf616a;">allegory-eng</span><span> x)]))
</span></code></pre>
<p>The <code>allegory-short</code> function was defined by writing out the three scenarios by which a phrase could be part of an allegory: it is either the Tamarian allegory, the Human allegory or the English translation. The only new structure we use here from core.logic is <code>l/fresh</code> which lets us introduce new (fresh) logic variables which have no binding as of yet. When using the various forms of <code>l/run</code> the parameters for the function are automatically given as fresh variables, but this function allows us to create them inside other parts of the logic program as well.</p>
<p>Now if we want to list, for example, five possible phrases that form part of an allegory we can call:</p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>(</span><span style="color:#bf616a;">l/run </span><span style="color:#d08770;">5 </span><span>[x]
</span><span>       (</span><span style="color:#bf616a;">allegory-short</span><span> x))
</span></code></pre>
<p>which will return five of the possible terms that are used as part of allegories.</p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>(&quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span> &quot;</span><span style="color:#a3be8c;">Beast at Tanagra.</span><span>&quot;
</span><span> &quot;</span><span style="color:#a3be8c;">Darmok and Jalad at Tanagra.</span><span>&quot;
</span><span> &quot;</span><span style="color:#a3be8c;">Gilgamesh, his plant eaten by a snake.</span><span>&quot;
</span><span> &quot;</span><span style="color:#a3be8c;">failure</span><span>&quot;)
</span></code></pre>
<p>With all the functions for logic programming we built up, lets try our hand at creating a logic program that generates variants of the Darmok story expressed through a sequence of allegories. In this scenario, much like in the episode any phrase, a Tamarian- or Human allegory or their English equivalent, could be used to describe parts of the story. In essence we can represent the story as a list of phrases, for example: (&quot;failure&quot;, &quot;Beast at Tanagra.&quot; &quot;Darmok and Jalad at Tanagra.&quot; &quot;successful-first-contact&quot; ). </p>
<p>We could put many restrictions on the order of the phrases, but for the sake of brevity we just want to ensure that each story starts with a phrase for <code>failure</code> and ends with a phrase for <code>successful-first-contact</code> much like the structure of the actual episode. In addition let's assume our stories are only five phrases long. </p>
<p>We can now define logic program to generate such stories as follows:</p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>(</span><span style="color:#b48ead;">defn </span><span style="color:#8fa1b3;">failure-any </span><span>[x]
</span><span>  (</span><span style="color:#bf616a;">l/fresh </span><span>[a1 a2 a3]
</span><span>           (</span><span style="color:#bf616a;">l/conde </span><span>[(</span><span style="color:#bf616a;">failure</span><span> x a1 a2)]
</span><span>                    [(</span><span style="color:#bf616a;">failure</span><span> a1 x a2)]
</span><span>                    [(</span><span style="color:#bf616a;">failure</span><span> a1 a2 x)])))
</span><span>
</span><span>(</span><span style="color:#b48ead;">defn </span><span style="color:#8fa1b3;">successful-first-contact-any </span><span>[x]
</span><span>  (</span><span style="color:#bf616a;">l/fresh </span><span>[a1 a2 a3]
</span><span>           (</span><span style="color:#bf616a;">l/conde </span><span>[(</span><span style="color:#bf616a;">successful-first-contact</span><span> x a1 a2)]
</span><span>                    [(</span><span style="color:#bf616a;">successful-first-contact</span><span> a1 x a2)]
</span><span>                    [(</span><span style="color:#bf616a;">successful-first-contact</span><span> a1 a2 x)])))
</span><span>
</span><span>(</span><span style="color:#b48ead;">defn </span><span style="color:#8fa1b3;">five-element-story </span><span>[x1</span><span style="color:#65737e;">,</span><span> x2</span><span style="color:#65737e;">,</span><span> x3</span><span style="color:#65737e;">,</span><span> x4</span><span style="color:#65737e;">,</span><span> x5]
</span><span>  (</span><span style="color:#bf616a;">l/fresh </span><span>[a1 a2 a3]
</span><span>           (</span><span style="color:#bf616a;">l/conde </span><span>[(</span><span style="color:#bf616a;">failure-any</span><span> x1)
</span><span>                     (</span><span style="color:#bf616a;">allegory-short</span><span> x2)
</span><span>                     (</span><span style="color:#bf616a;">allegory-short</span><span> x3)
</span><span>                     (</span><span style="color:#bf616a;">allegory-short</span><span> x4)
</span><span>                     (</span><span style="color:#bf616a;">successful-first-contact-any</span><span> x5)])))
</span></code></pre>
<p>Every construct we used to build these functions should be familiar based on the previous examples. We just needed to define two special versions of our goals for the shorthand version of allegories: one for failure and one for successful first contact.</p>
<p>For example if we want five solutions that fulfill all the criteria for such stories we can call the following code: </p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>(</span><span style="color:#bf616a;">l/run </span><span style="color:#d08770;">5 </span><span>[x1 x2 x3 x4 x5]
</span><span>       (</span><span style="color:#bf616a;">five-element-story</span><span> x1 x2 x3 x4 x5))
</span></code></pre>
<p>which for example could return:</p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>([&quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Picard and Dathon at El-Adrel.</span><span>&quot;]
</span><span> [&quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Picard and Dathon at El-Adrel.</span><span>&quot;]
</span><span> [&quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">successful-first-contact</span><span>&quot;]
</span><span> [&quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Beast at Tanagra.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Picard and Dathon at El-Adrel.</span><span>&quot;]
</span><span> [&quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Beast at Tanagra.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Picard and Dathon at El-Adrel.</span><span>&quot;])
</span></code></pre>
<p>As one can see the logic program will exhaustively go through all the possible ways the goals can fulfilled and list them up to limit given as a parameter for <code>l/run</code>. The results are not necessarily unique if there are multiple ways to fulfill the goals. This can be seen in the first and second answers as the phrase &quot;Picard and Dathon at El-Adrel.&quot; is both the Tamarian and Human allegory for successful first contact. </p>
<p>The above restrictions allow for a lot of the same allegories used within the story. For this, one can define new restrictions and further fine tune the story generation. For example, one can create restrictions on the number of duplicate phrases used, or could ensure that there is more diversity in the phrase type (Tamarian, Human, English) is used. Declaring new restrictions, combining them with existing ones and using the same mechanism to derive any number of answers is one of the core strengths of a logic programming system such as core.logic.</p>
<p>As a final example to show how logic programming can be embedded into a (regular) program, we create a logic program inside a regular Clojure function that creates n-number of stories of a given length. Take a quick look at the following code:</p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>(</span><span style="color:#b48ead;">defn </span><span style="color:#8fa1b3;">n-element-story </span><span>[nr-of-elements stories]
</span><span>  (</span><span style="color:#bf616a;">let </span><span>[vars (</span><span style="color:#bf616a;">repeatedly</span><span> nr-of-elements l/lvar)
</span><span>        first-var (</span><span style="color:#bf616a;">first</span><span> vars)
</span><span>        middle (</span><span style="color:#bf616a;">drop-last </span><span>(</span><span style="color:#bf616a;">rest</span><span> vars))
</span><span>        last-var (</span><span style="color:#bf616a;">last</span><span> vars)]
</span><span>    (</span><span style="color:#bf616a;">l/run</span><span> stories [q]
</span><span>           (</span><span style="color:#bf616a;">l/conde </span><span>[(</span><span style="color:#bf616a;">l/==</span><span> q vars)
</span><span>                     (</span><span style="color:#bf616a;">l/distincto</span><span> q)
</span><span>                     (</span><span style="color:#bf616a;">failure-any</span><span> first-var)
</span><span>                     (</span><span style="color:#bf616a;">successful-first-contact-any</span><span> last-var)
</span><span>                     (</span><span style="color:#bf616a;">l/everyg</span><span> allegory-short middle)]))))
</span></code></pre>
<p>Without going too in-depth on every part of this function, it programmatically creates n-number of fresh variables based on the given parameter. It then unifies these with the parameters of a run execution inside the function and returns them. For example, six stories of four elements can be requested by the call:</p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>(</span><span style="color:#bf616a;">n-element-story </span><span style="color:#d08770;">4 6</span><span>)
</span></code></pre>
<p>which will result in the stories:</p>
<pre data-lang="clojure" style="background-color:#2b303b;color:#c0c5ce;" class="language-clojure "><code class="language-clojure" data-lang="clojure"><span>((&quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Beast at Tanagra.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Darmok and Jalad at Tanagra.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Picard and Dathon at El-Adrel.</span><span>&quot;)
</span><span> (&quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Beast at Tanagra.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Darmok and Jalad on the ocean.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Picard and Dathon at El-Adrel.</span><span>&quot;)
</span><span> (&quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Beast at Tanagra.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Gilgamesh, his plant eaten by a snake.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Picard and Dathon at El-Adrel.</span><span>&quot;)
</span><span> (&quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Beast at Tanagra.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">failure</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Picard and Dathon at El-Adrel.</span><span>&quot;)
</span><span> (&quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Beast at Tanagra.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Bull of Heaven.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Picard and Dathon at El-Adrel.</span><span>&quot;)
</span><span> (&quot;</span><span style="color:#a3be8c;">Shaka, when the walls fell.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Darmok and Jalad at Tanagra.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Beast at Tanagra.</span><span>&quot;
</span><span>  &quot;</span><span style="color:#a3be8c;">Picard and Dathon at El-Adrel.</span><span>&quot;))
</span></code></pre>
<p>There you have it, a very quick overview of using core.logic for logic programming. If you would like to experiment further the code used in this article is <a href="https://github.com/newres/darmok-core-logic">available</a>. Here we only scratched the surface of what is possible in a logic programming environment such as core.logic. Feel free to check it out, or any other <a href="http://minikanren.org/#implementations">miniKanren implementation available in your language</a>.</p>
<p>I hope that, much like the Darmok episode, this article has expanded your horizons on communicating. Logic programming is a very interesting, and often underutilized programming paradigm. The core.logic/miniKanren logic programming language is a great system to get started with it. I hope that this, perhaps first, contact with Logic Programming or core.logic aids you in your future endeavors.</p>


    </div>
  </section>
</body>

</html>
