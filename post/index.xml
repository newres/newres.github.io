<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Newres Al Haider</title>
    <link>/post/</link>
    <description>Recent content in Posts on Newres Al Haider</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Newres Al Haider</copyright>
    <lastBuildDate>Sun, 01 Jan 2017 00:00:00 +0100</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>The Art of Choosing a Programming Language</title>
      <link>/post/art-of-choosing-language/</link>
      <pubDate>Sun, 18 Mar 2018 00:00:00 +0100</pubDate>
      
      <guid>/post/art-of-choosing-language/</guid>
      <description>

&lt;p&gt;Programmers, like professionals in other fields, are passionate about their tools. One of the main elements in the toolbox of coders are programming languages. They allow their users to express solutions through code to tackle a large variety of problems in many domains.&lt;/p&gt;

&lt;p&gt;Programming is also an art, as described in the article by Donald Knuth titled &lt;a href=&#34;http://www.paulgraham.com/knuth.html&#34; target=&#34;_blank&#34;&gt;Computer Programming as an Art&lt;/a&gt; and in certain aspects of programming languages can be seen as art styles.&lt;/p&gt;

&lt;p&gt;As can be expected with many things that people are passionate about, whether viewed as a tool or an art style, coders can bond or argue about programming languages. Like philosophers of old, these discussions can go quite into depth, but to the outsider the arguments made or the sentiments behind them can be quite opaque.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;/img/post/2018-03/art-of-choosing-language/schoolofathens.jpg&#34; alt=&#34;School of Athens by Raphael&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;If programming languages existed back then, I am sure they would be a hotly argued topic.&lt;/h4&gt;
        &lt;p&gt;
        School of Athens by Raphael
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Here I hope to shed some light to the casual observer on what makes programmers passionate about these languages and why some prefer one over the other. Such analysis can be quite subjective, and very much dependent on the writers experiences and preferences, but I will try my best to give an impartial overview.&lt;/p&gt;

&lt;p&gt;In theory many general purpose programming languages are capable of doing the same things. The most commonly used programming languages are Turing complete, meaning that they can all simulate the workings of any Turing machine. Without getting into the full description of what a Turing machine is, for the reader unfamiliar with the concept, this means that any of the languages can express programs for similar tasks.&lt;/p&gt;

&lt;p&gt;There are thousands of programming languages. Some older, and going back to the 50s, 60s and 70s and with considerable use still. Others have been released as recently as the last 10 years, and have gained considerable following. Given as I have mentioned that theoretically all these languages can do the same things, one could wonder why new languages are designed.&lt;/p&gt;

&lt;h2 id=&#34;history&#34;&gt;History&lt;/h2&gt;

&lt;p&gt;Historically, the original computers were instructed by a pure machine language, for example 0s and 1s. Writing programs this way can be tedious and error prone, and the results code can be very difficult to read. This is one of reasons why assembly languages were created. These are languages that are still very much tied into the instruction set of a particular machine, but in a more human readable form, where symbolic names are given for machine instructions. These would be then translated to the pure machine language, to instruct the machine.&lt;/p&gt;

&lt;p&gt;While reading and writing programs becomes easier this way, using assembly languages still has disadvantages. First, these languages are still very much tied to the hardware. Different instruction architectures can mean that a program for the same goal would have to be written differently for each architecture. Second, for many the instructions that one has to write this way are still very low level. The argument is made that with a better set of abstractions over assembly, programs can be written in a better way. A program written with such abstractions could be translated, compiled, to the required machine code specific for the required architecture.&lt;/p&gt;

&lt;p&gt;The question of which abstractions need to be utilized is at the heart of why there are so many different programming languages. People have different ideas on what these abstractions might be, what the benefits and drawbacks of applying them are. This is at the heart of why people design and use newer programming languages. In the following sections we go through some of the aspects on these abstractions.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;/img/post/2018-03/art-of-choosing-language/pyramids.jpg&#34; alt=&#34;The Giza Pyramids © Robbster1983&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Much like with ancients wonders of next to a modern city, with programming languages old also gives rise to the new, and often co-exists with it .&lt;/h4&gt;
        &lt;p&gt;
        The Giza Pyramids © Robbster1983
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;h2 id=&#34;paradigms-and-style&#34;&gt;Paradigms and Style&lt;/h2&gt;

&lt;p&gt;As mentioned before, there are different opinions on how programs could be constructed. There are various subjects about on which people have opinions about: how the code is organized and how it is executed, among other elements. This is very much similar to how art styles function. For example the same subject can be painted in two differing styles.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;/img/post/2018-03/art-of-choosing-language/last-supper-da-vinci.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;The Last Supper (Leonardo da Vinci) one of the most famous Renaissance style paintings.&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;figure &gt;
    
        &lt;img src=&#34;/img/post/2018-03/art-of-choosing-language/last-supper-tintoretto.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;The Last Supper (Tintoretto) depicts the same subject but in a Mannerist, proto-Baroque style.&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Programming languages can be be classified on the different styles, &lt;em&gt;programming paradigms&lt;/em&gt; based on the common elements in the approaches.  Some paradigms include:&lt;/p&gt;

&lt;h3 id=&#34;imperative&#34;&gt;Imperative&lt;/h3&gt;

&lt;p&gt;Imperative code can be seen as a set of commands for the computer to perform. This type of paradigm matches very strongly with how computer hardware is working, as nearly all computer hardware is designed the execute machine language, which is in itself is written in imperative style.&lt;/p&gt;

&lt;h3 id=&#34;procedural&#34;&gt;Procedural&lt;/h3&gt;

&lt;p&gt;One of the ways one can structure a program is to group together a series of commands. These groups, &lt;em&gt;procedures&lt;/em&gt;, can then be called, used or reused as a single entity.&lt;/p&gt;

&lt;h3 id=&#34;object-oriented&#34;&gt;Object-Oriented&lt;/h3&gt;

&lt;p&gt;Object oriented code uses the notion of &lt;em&gt;objects&lt;/em&gt; to organize code. An object is an encapsulation of related state and behavior. For example, consider a software that needs to represent a vehicle. The elements of the state that describe the object, such as &lt;em&gt;colour&lt;/em&gt; and &lt;em&gt;make&lt;/em&gt;, are called attributes.  Various functionality related to the object, such as calculating the price of the car, are called methods. These concepts allow reuse, as the objects for a car and a motorcycle can share functionality.&lt;/p&gt;

&lt;h3 id=&#34;declarative&#34;&gt;Declarative&lt;/h3&gt;

&lt;p&gt;In declarative programming, one describes, or more aptly declares what the problem is as opposed to detailing the steps on how to solve it. This contrasts with imperative programming, where one gives the instructions on how to solve it directly.&lt;/p&gt;

&lt;h3 id=&#34;functional&#34;&gt;Functional&lt;/h3&gt;

&lt;p&gt;Functional programming is one form of declarative programming where programs are constructed using &lt;em&gt;functions&lt;/em&gt;, which are analogous and inspired by to mathematical functions. The intention is that these functions are ideally side effect free: their output is dependent solely on their input. This can make code easier to understand and allows for easier use of code written this way.&lt;/p&gt;

&lt;h3 id=&#34;logic&#34;&gt;Logic&lt;/h3&gt;

&lt;p&gt;The logic paradigm is based around expressing code as a set of logical axioms. These axioms can then be used as a from of knowledge base to derive new knowledge and query. The programs themselves then can be posed as a query in this system. For example, if the knowledge is defined with the axioms &amp;ldquo;Tweety is a bird&amp;rdquo; and &amp;ldquo;Birds are animals&amp;rdquo;, the system should be able to answer the queries: &amp;ldquo;Is Tweety and animal?&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;A language can focus on supporting a particular paradigm heavily or have a strong preference for it. For example &lt;a href=&#34;https://www.haskell.org/&#34; target=&#34;_blank&#34;&gt;Haskell&lt;/a&gt; or &lt;a href=&#34;https://clojure.org/&#34; target=&#34;_blank&#34;&gt;Clojure&lt;/a&gt; lean quite heavily on the functional paradigm, while &lt;a href=&#34;http://www.swi-prolog.org/&#34; target=&#34;_blank&#34;&gt;Prolog&lt;/a&gt; is one of the main logic programming languages. Others, provide an explicit merge of various methodologies, such as &lt;a href=&#34;https://www.scala-lang.org/&#34; target=&#34;_blank&#34;&gt;Scala&lt;/a&gt; that combines elements of object orientation and functional programming.&lt;/p&gt;

&lt;p&gt;Preference for a particular language can go beyond the programming paradigms used. Syntax, the structure of how code is written, can matter quite a bit for person&amp;rsquo;s view on a particular language. For example &lt;a href=&#34;https://www.python.org/&#34; target=&#34;_blank&#34;&gt;Python&lt;/a&gt; uses indentation for managing the control flow of the code, as opposed to symbols in other languages.&lt;/p&gt;

&lt;p&gt;Such preference can go even beyond the actual code itself to the tools one uses to write. While any text editor for editing text can often suffice, people can have differing expectations with regards to integrated development environments (IDEs) or other tools to edit and analyze the code. The lack or existence of specific tooling can also be a factor when deciding between languages.&lt;/p&gt;

&lt;h2 id=&#34;available-code-and-libraries&#34;&gt;Available Code and Libraries&lt;/h2&gt;

&lt;p&gt;Most coding is done with a particular purpose in mind, and it is rarely the case that the programmer can build everything from the ground up for such a task. In order to build interesting programs, one has to utilize existing knowledge, much like someone would utilize knowledge in a library to come to new insights.&lt;/p&gt;

&lt;figure&gt;
  &lt;img src=&#34;/img/post/2018-03/art-of-choosing-language/bibliotheca-alexandrina.jpg&#34;  /&gt;
  &lt;figcaption&gt;
      &lt;h4&gt;The Bibliotheca Alexandrina. Photo © Carsten Whimster licensed under &lt;a href =&#34;https://creativecommons.org/licenses/by/3.0/&#34;&gt; CC BY 3.0 &lt;/a&gt;.&lt;/h4&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Existing code can be used as a foundation from which the program can be built. Roughly speaking existing code comes in three main forms. It is either being part of the language (often called the standard library of the language), some external libraries extending the language for a particular purpose, or an existing code base of the application that one can improve upon.&lt;/p&gt;

&lt;p&gt;The standard library contains various functionality included with the language itself. For example ways of manipulating files, various connection protocols, support for certain file formats, etc. Of course it is very much helpful if particular support for a certain feature that aims to use is already available with the language itself. This means less code to write and connect. On the other hand there is also some tension with regards to including too many features in the standard library, especially if certain parts of it become outdated, which enlarges the language and makes it more unwieldy.&lt;/p&gt;

&lt;p&gt;The external libraries that one can use in a language can also influence the choice of a language. Certain languages have a lot of library support for specific tasks. For example &lt;a href=&#34;https://www.python.org/&#34; target=&#34;_blank&#34;&gt;Python&lt;/a&gt; has a large and active following in the Data Science community. Other languages have a lot of support for many different tasks simply due their age and user base such as &lt;a href=&#34;https://www.java.com/en/&#34; target=&#34;_blank&#34;&gt;Java&lt;/a&gt;. By using libraries one does not need to implement certain features from scratch but can reuse existing work and focus on their specific problem at hand.&lt;/p&gt;

&lt;p&gt;Finally, not all development starts from scratch, often one has to make additions or improvement to an existing program, in which case the choice of the language has already been made. While a rewrite of the code can often be tempting, linking between two code programming languages is not always trivial. It is often a good idea to continue with an existing language.&lt;/p&gt;

&lt;p&gt;There are some exceptions to this as some languages have been designed with the ground up to inter-operate with other languages. A good example of this is &lt;a href=&#34;https://clojure.org/&#34; target=&#34;_blank&#34;&gt;Clojure&lt;/a&gt; has great interop with &lt;a href=&#34;https://www.java.com/en/&#34; target=&#34;_blank&#34;&gt;Java&lt;/a&gt; and/or &lt;a href=&#34;https://en.wikipedia.org/wiki/JavaScript&#34; target=&#34;_blank&#34;&gt;JavaScript&lt;/a&gt;. This allows it to leverage existing libraries already written, and makes it much more attractive to use.&lt;/p&gt;

&lt;h2 id=&#34;existing-knowledge&#34;&gt;Existing Knowledge&lt;/h2&gt;

&lt;p&gt;Writing code is rarely trivial, and neither is learning new programming languages. Although previous experience helps, especially when dealing with languages with known paradigms, due to slight or large differences it can take a while to get used to the new language and libraries. With constantly looming deadlines and pressure to deliver, it can make sense to minimize the work that needs to be done. It is perfectly valid to work with a language that one already knows.&lt;/p&gt;

&lt;h2 id=&#34;curiosity&#34;&gt;Curiosity&lt;/h2&gt;

&lt;p&gt;On the other hand learning a new language, especially in a new paradigm or other innovative features, can be quite interesting. It not only allows for work on existing code written in the new language but it also gives insights in how to program which is beneficial as a programmer in general no matter what language he is using.&lt;/p&gt;

&lt;h2 id=&#34;speed&#34;&gt;Speed&lt;/h2&gt;

&lt;p&gt;As mentioned earlier, commonly used programming languages are abstractions over machine code that can do more of less the same thing computationally. What abstractions are used however can influence the speed of executing the program, as well as the time of translating the code in the programming language to machine code.&lt;/p&gt;

&lt;p&gt;A common abstraction that can influence the speed of executing the program is how memory is managed. During the running of a program certain information needs to be stored. A way to do this is to allocate space in the computers memory, keep it around while needed and remove it afterwards. This latter portion, can be quite difficult to manage manually, as if one does it prematurely the program might crash or have other bugs. Not removing it would fill the memory with garbage, which makes the program use up more and more memory till it crashes.&lt;/p&gt;

&lt;p&gt;A solution to these problems is automatic garbage collection: a way for the computer to automatically manage and clean up memory. While this is a good solution in many cases, this process comes with an overhead, and can be unpredictable when the time and resource consuming cleanup happens. In most cases this overhead is trivial to pay for eliminating a whole suite of potential bugs. However in certain scenarios, such as real-time high performance games, it could be too much to pay.&lt;/p&gt;

&lt;p&gt;The other issue of speed, translating the code from the programming language to machine code, can also be a consideration. Development requires making changes to code and checking whether the changes work. If the process of getting feedback takes a long time, due to these translations, it can destroy a programmers productivity. &lt;a href=&#34;https://golang.org/&#34; target=&#34;_blank&#34;&gt;Golang&lt;/a&gt; is a language that is explicitly designed for fast compilation.&lt;/p&gt;

&lt;h2 id=&#34;safety&#34;&gt;Safety&lt;/h2&gt;

&lt;p&gt;Safety is in many cases the flip side to the speed argument. Certain abstractions cost you in speed but provide you with safety in return. Different languages tend to make different trade-offs with this regard. For example one of the relatively new languages, &lt;a href=&#34;https://www.rust-lang.org/en-US/&#34; target=&#34;_blank&#34;&gt;Rust&lt;/a&gt; aims at focus on zero cost abstractions: abstractions with little to no run-time performance penalty.&lt;/p&gt;

&lt;p&gt;One contentious aspect of safety is the use of type systems. Types allow the coder to specify various categories, such as numbers, persons, cars, etc as well as their requirements to be fulfilled within the context of the program. Types can be checked both statically, before the system is run, or dynamically, during the running of the program. Some people swear by very expressive type systems: where types can specify very detailed features of the things the program wants to represent. This then can be used for checking code for correctness, both before and during the running of a program, as well as documentation. On the other hand type checking is not free: it can make translating the compilation into machine code a much slower process. Some people also consider the writing and checking of types themselves very cumbersome during initial development, where quick iteration can be slowed down by specifying detailed types.&lt;/p&gt;

&lt;p&gt;There is a whole spectrum of possible stances with regards to type systems. For example, certain languages such as &lt;a href=&#34;https://www.haskell.org/&#34; target=&#34;_blank&#34;&gt;Haskell&lt;/a&gt; and &lt;a href=&#34;https://www.idris-lang.org/&#34; target=&#34;_blank&#34;&gt;Idris&lt;/a&gt; are designed from the ground up with very expressive type systems that are statically checked. Others, for example &lt;a href=&#34;https://www.dartlang.org/&#34; target=&#34;_blank&#34;&gt;Dart&lt;/a&gt; which started off as having optional types but adds mandatory types in the latest iteration to help with tooling, take a more balanced approach. &lt;a href=&#34;https://golang.org/&#34; target=&#34;_blank&#34;&gt;Golang&lt;/a&gt; explicitly has a static, but minimalist, type system that allows for fast compilation.  There are also languages, such as &lt;a href=&#34;https://clojure.org/&#34; target=&#34;_blank&#34;&gt;Clojure&lt;/a&gt; that instead of static types, use contract systems to ensure safety at run-time and allow for documentation and testing.&lt;/p&gt;

&lt;h2 id=&#34;deployment&#34;&gt;Deployment&lt;/h2&gt;

&lt;p&gt;While most general purpose programming languages can be made to run in all environments, they are not always available. In certain environments, such as mobile or on the web, only specific languages are supported. For example on Android &lt;a href=&#34;https://www.java.com/en/&#34; target=&#34;_blank&#34;&gt;Java&lt;/a&gt; and &lt;a href=&#34;https://www.java.com/en/&#34; target=&#34;_blank&#34;&gt;Kotlin&lt;/a&gt; are officially supported, while on the web &lt;a href=&#34;https://en.wikipedia.org/wiki/JavaScript&#34; target=&#34;_blank&#34;&gt;JavaScript&lt;/a&gt; is the current Lingua Franca of the web. This means that it can be quite a herculean effort to make other languages work in such environments, and going with the most supported option is easier.&lt;/p&gt;

&lt;p&gt;The way certain languages can get around on this hindrance is by using the more commonly supported language as the target to translate into. For example &lt;a href=&#34;https://clojurescript.org/&#34; target=&#34;_blank&#34;&gt;ClojureScript&lt;/a&gt; compiles into &lt;a href=&#34;https://en.wikipedia.org/wiki/JavaScript&#34; target=&#34;_blank&#34;&gt;JavaScript&lt;/a&gt;. And in some cases, other developers have made the effort to get frameworks up and running that allow the use of a different language, such as the use of &lt;a href=&#34;https://facebook.github.io/react-native/&#34; target=&#34;_blank&#34;&gt;React Native&lt;/a&gt; and &lt;a href=&#34;https://flutter.io/&#34; target=&#34;_blank&#34;&gt;Flutter&lt;/a&gt; that allow the use of &lt;a href=&#34;https://en.wikipedia.org/wiki/JavaScript&#34; target=&#34;_blank&#34;&gt;JavaScript&lt;/a&gt; and &lt;a href=&#34;https://www.dartlang.org/&#34; target=&#34;_blank&#34;&gt;Dart&lt;/a&gt; respectively to develop mobile applications.&lt;/p&gt;

&lt;h2 id=&#34;the-team-and-beyond&#34;&gt;The Team and Beyond&lt;/h2&gt;

&lt;p&gt;One final aspect of choosing a programming language, which can be surprisingly significant, is which language is beneficial to the team, as opposed to an individual developer. Different teams bring different expertise to the table, and while most professionals are often quite willing and able to use a new language if it is most suited to the task at hand, this can still be a cost that might be better spent on developing the application. From an employers perspective it can also often be beneficial to stick to more commonly used languages as it can be easier to find future employees versed in the language used. On the other hand, there are many professionals that would be quite willing to jump on the chance of using the latest programming languages, in which case the choice for a newer or more niche language can be a competitive advantage from a recruiting perspective.&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;I hope this article gave some insight on why programmers pick and argue about programming languages. Despite all the various differences and arguments it is also very important to note, that great software has been written in many different languages, that is both excellent code and solves important problems. And while picking the right tool for the job is an important, it can be just an aspect of the art of solving problems with code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Data Interlinked</title>
      <link>/post/interlinked-data/</link>
      <pubDate>Sun, 18 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/interlinked-data/</guid>
      <description>&lt;p&gt;&lt;em&gt;This article contains some very minor spoilers for the Blade Runner 2049 movie. If you have not seen it yet, by all means do, it is really good.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;And blood-black nothingness began to spin&amp;hellip; A system of cells interlinked within cells interlinked within cells interlinked within one stem&amp;hellip; And dreadfully distinct against the dark, a tall white fountain played.&amp;rdquo;&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;/img/post/interlinked-data/palefire.jpg&#34; alt=&#34;Cover of the novel Pale Fire © Berkley Medallion&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Pale Fire by Vladimir Nabokov&lt;/h4&gt;
        &lt;p&gt;
        Cover of the novel Pale Fire © Berkley Medallion
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;The above is a quote from the poem &lt;em&gt;Pale Fire&lt;/em&gt;. It occurs in the novel titled &lt;em&gt;Pale Fire&lt;/em&gt; by Vladimir Nabokov which has been recently used in the movie &lt;em&gt;Blade Runner 2049&lt;/em&gt;. In the movie it was part of the Baseline test, a way to test the emotional response of a Replicant. The reason they undergo this process is because their creators fear that the connections they might make in their lives would give them emotions that would interfere with their intended purpose.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;/img/post/interlinked-data/bladerunner2049.png&#34; alt=&#34;Poster for the movie © Columbia Pictures&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Blade Runner 2049&lt;/h4&gt;
        &lt;p&gt;
        Poster for the movie © Columbia Pictures
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;In life, such relationships always surround us. They are not just between people, but in our work, in our beliefs, in our art and in the knowledge we represent.&lt;/p&gt;

&lt;p&gt;Suppose we intend to describe the link between the movie &lt;em&gt;Blade Runner&lt;/em&gt; and the book &lt;em&gt;Pale Fire&lt;/em&gt;. We can summarize this information with a number of facts.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Blade Runner is a movie. 
Blade Runner has a character named K.
K is a Replicant.
Replicants must pass a Baseline Test.
Baseline Test is based on the poem Pale Fire.
Pale Fire is written by Vladimir Nabokov.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above facts show that the links that can tie together various pieces of knowledge. One can trace the connections from a simple description of a movie, released in 2017, to the author Vladimir Nabokov, as was intended by the writers of the movie.&lt;/p&gt;

&lt;p&gt;Although the above recitation of facts is easy to follow, from a knowledge representation perspective one can find some issues with it.&lt;/p&gt;

&lt;p&gt;First the description is imprecise. As the &lt;em&gt;Blade Runner&lt;/em&gt; could refer to the newer &lt;em&gt;Blade Runner 2049&lt;/em&gt; movie as opposed to the 1982 original titled &lt;em&gt;Blade Runner&lt;/em&gt;.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;/img/post/interlinked-data/bladerunner.jpg&#34; alt=&#34;Blade Runner movie poster © 1982 The Ladd Company&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;The first movie titled Blade Runner&lt;/h4&gt;
        &lt;p&gt;
        Blade Runner movie poster © 1982 The Ladd Company
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Second the set of facts is incomplete. The poem &lt;em&gt;Pale Fire&lt;/em&gt; is indeed written by Vladimir Nabokov, but it is presented in the book &lt;em&gt;Pale Fire&lt;/em&gt;, also written by Nabokov as the work of the fictional poet &lt;em&gt;John Shade&lt;/em&gt;. The set of facts here fails to make the explicit distinction between &lt;em&gt;Pale Fire (poem)&lt;/em&gt; and &lt;em&gt;Pale Fire (book)&lt;/em&gt;, and that the poem is contained in the book.&lt;/p&gt;

&lt;p&gt;Third, and perhaps most importantly, the above list of facts relies a lot on the users grasp of the English natural language. For a program, it can be surprisingly difficult to understand the relationships such as &amp;ldquo;is a&amp;rdquo;, &amp;ldquo;is based on&amp;rdquo;, &amp;ldquo;named&amp;rdquo;, etc between the various elements in the text.&lt;/p&gt;

&lt;p&gt;These issues seem somewhat nit-picky, as this information can be derived from the rest of the article. However this means that the knowledge in the summary does not stand on its own. If those facts are detailed without the rest of the article, or if the reader of them is a machine, and not a person that can easily add some context, they might lead them to incorrect or insufficient conclusions. They might get wrong information that the 1982 movie Blade Runner has a character named K, or fail to see the link that poem is contained in the book by the same author. And although in the case of Blade Runner, these issues might seem small, this is different if the knowledge relates to financial, legal or clinical domains. Here, mistakes or omissions can be costly.&lt;/p&gt;

&lt;p&gt;Having a larger list of more detailed facts can help with these issues, but to a certain extent they still remain due to the ambiguity of the natural language. In addition the fact that is often very easy to skip over implicit details. This is especially true for the issue of a computer not being able to make (enough) sense of this information.&lt;/p&gt;

&lt;p&gt;A proposed solution to these issues is &lt;a href=&#34;https://www.w3.org/standards/semanticweb/data&#34; target=&#34;_blank&#34;&gt;Linked Data&lt;/a&gt; and in particular &lt;a href=&#34;https://www.w3.org/standards/techs/rdf#w3c_all&#34; target=&#34;_blank&#34;&gt;Resource Description Framework (RDF)&lt;/a&gt;, with which Linked Data data can be expressed. These technologies allow us to represent the above facts in a more formal and precise way, that can make it both human and machine read- and write-able.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;/img/post/interlinked-data/rdf.png&#34; alt=&#34;Logo of RDF © W3C&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Resource Description Framework&lt;/h4&gt;
        &lt;p&gt;
        Logo of RDF © W3C
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;One significant feature of RDF is that requires precise naming. Many elements of it are either a &lt;a href=&#34;https://en.wikipedia.org/wiki/International_Resource_Identifier&#34; target=&#34;_blank&#34;&gt;International Resource Identifier (IRI)&lt;/a&gt; or some raw data-types. Good examples of the former are URLs, such as the link to this website: &lt;a href=&#34;http://www.newresalhaider.com&#34; target=&#34;_blank&#34;&gt;http://www.newresalhaider.com&lt;/a&gt; , that allows one to find a web resource. Examples of the later are texts or numbers, such as &amp;ldquo;Blade Runner&amp;rdquo; or 15 respectively.&lt;/p&gt;

&lt;p&gt;The other significant feature of RDF is that most knowledge is represented as a set of facts, where each fact is expressed as subject, predicate object triples. For example the fact &amp;ldquo;Blade Runner is a movie&amp;rdquo; is expressed with the subject &amp;ldquo;Blade Runner&amp;rdquo; the predicate &amp;ldquo;is a&amp;rdquo; and the object &amp;ldquo;movie&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Putting this together in RDF (using the &lt;a href=&#34;https://www.w3.org/TR/turtle/&#34; target=&#34;_blank&#34;&gt;Turtle&lt;/a&gt; notation) you would get a triple such as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Turtle&#34;&gt;&amp;lt;http://www.newresalhaider.com/ontologies/bladerunner/blade-runner&amp;gt; &amp;lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/bladerunner/movie&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example is an RDF way of saying &amp;ldquo;Blade Runner is a type of movie&amp;rdquo; or alternatively &amp;ldquo;Blade runner is a movie&amp;rdquo;. This type of representation shows us a couple of benefits. First we are now being more precise as each element in the triple can refer to one specific resource, for example Blade Runner or Movie, where there IRI makes sure we do not necessarily confuse the term with anything else. Second this also shows off the fact that you can link to resources from different places: the predicate &amp;ldquo;type&amp;rdquo; is from a completely different domain. This allows us to re-use knowledge that has already been defined. As one can expect saying something is of a &amp;ldquo;type&amp;rdquo;, for example an apple is a type of a fruit, is actually very common. This is one of the main strengths of what makes Linked Data so powerful, one can re-use knowledge already stated.&lt;/p&gt;

&lt;p&gt;Typing out the full IRI each time can be pretty bothersome, and it does not help the readability either. Thankfully we can define a common prefix we use separately, and just write the last part of the IRI in each case. In this case we define a base prefix and we refer to subject and object by &amp;ldquo;&amp;lt;#blade-runner&amp;gt;&amp;rdquo; and &amp;ldquo;&amp;lt;#movie&amp;gt;&amp;rdquo; respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Turtle&#34;&gt;@base &amp;lt;http://www.newresalhaider.com/ontologies/bladerunner&amp;gt; .
&amp;lt;#blade-runner&amp;gt; &amp;lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&amp;gt; &amp;lt;#movie&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can do similar things when linking elements that have been already defined elsewhere. In this case we define a prefix to use as an abbreviation while writing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Turtle&#34;&gt;@base &amp;lt;http://www.newresalhaider.com/ontologies/bladerunner&amp;gt; .
@prefix rdf: &amp;lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&amp;gt; .

&amp;lt;#blade-runner&amp;gt; rdf:type &amp;lt;#movie&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In practice, &amp;ldquo;rdf:type&amp;rdquo; as a predicate is so common that there is an even simpler notation. We can use &amp;lsquo;a&amp;rsquo; as a predicate, which is in line with what we intend to express: &amp;ldquo;Blade Runner is a movie&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The resulting RDF facts look as follows (note that the rdf prefix could be omitted here as the &amp;ldquo;a&amp;rdquo; abbreviation does not make it necessary):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Turtle&#34;&gt;@base &amp;lt;http://www.newresalhaider.com/ontologies/bladerunner&amp;gt; .
@prefix rdf: &amp;lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&amp;gt; .

&amp;lt;#blade-runner&amp;gt; a &amp;lt;#movie&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we aim to write something that is just a text as a subject, say when referring to the title of a movie , we can do that as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Turtle&#34;&gt;@base &amp;lt;http://www.newresalhaider.com/ontologies/bladerunner&amp;gt; .
@prefix rdf: &amp;lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&amp;gt; .

&amp;lt;#blade-runner&amp;gt; a &amp;lt;#movie&amp;gt;.
&amp;lt;#blade-runner&amp;gt; &amp;lt;#title&amp;gt; &amp;quot;Blade Runner 2049&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this way of writing, we can actually rewrite our original set of facts as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Turtle&#34;&gt;@base &amp;lt;http://www.newresalhaider.com/ontologies/bladerunner&amp;gt; .
@prefix rdf: &amp;lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&amp;gt; .
@prefix foaf: &amp;lt;http://xmlns.com/foaf/0.1/&amp;gt; .

&amp;lt;#blade-runner&amp;gt; a &amp;lt;#movie&amp;gt;.
&amp;lt;#blade-runner&amp;gt; &amp;lt;#title&amp;gt; &amp;quot;Blade Runner 2049&amp;quot;.
&amp;lt;#blade-runner&amp;gt; &amp;lt;#has-character&amp;gt; &amp;lt;#K&amp;gt;.
&amp;lt;#K&amp;gt; foaf:name &amp;quot;K&amp;quot;.
&amp;lt;#K&amp;gt; a &amp;lt;#replicant&amp;gt;.
&amp;lt;#replicant&amp;gt; &amp;lt;#must-pass&amp;gt; &amp;lt;#baseline-test&amp;gt;.
&amp;lt;#baseline-test&amp;gt; &amp;lt;#based-on&amp;gt; &amp;lt;#pale-fire-poem&amp;gt;.
&amp;lt;#pale-fire-poem&amp;gt; &amp;lt;#included-in&amp;gt; &amp;lt;#pale-fire-book&amp;gt;.
&amp;lt;#pale-fire-book&amp;gt; &amp;lt;#written-by&amp;gt; &amp;lt;#nabokov&amp;gt;.
&amp;lt;#nabokov&amp;gt; foaf:name &amp;quot;Vladimir Nabokov&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this version we suddenly defined our list of facts in a more formal manner than previously. This makes it much more simpler for machines to understand this set of facts. In fact we actually used the &lt;a href=&#34;https://en.wikipedia.org/wiki/FOAF_(ontology)&#34; target=&#34;_blank&#34;&gt;Friend of a Friend (FOAF) ontology&lt;/a&gt; to use the notion of name that is also used when talking about relationships between people. In fact, one could argue that using an existing movie dataset, such as the &lt;a href=&#34;https://old.datahub.io/dataset/linkedmdb&#34; target=&#34;_blank&#34;&gt;Linked Movie Database&lt;/a&gt; would have been even better, which we will leave as an exercise for the reader.&lt;/p&gt;

&lt;p&gt;Hopefully I could show a glimpse of the possibilities the &lt;a href=&#34;https://www.w3.org/standards/semanticweb/&#34; target=&#34;_blank&#34;&gt;Semantic Web&lt;/a&gt; for which Linked Data forms the basis, with this example. Of course the above is just scratching the surface of what it can be done with RDF, Linked Data. With each addition, our set of facts could grow. One could go beyond a single movie and build a document of poems that are references in movies, or a knowledge base of the Blade Runner franchise. It might be easier than one expects, due to the fact that knowledge, much like people are&amp;hellip;&lt;/p&gt;

&lt;p&gt;Interlinked.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Trouble with Triples</title>
      <link>/post/trouble-with-triples/</link>
      <pubDate>Sun, 28 Jan 2018 00:00:00 +0100</pubDate>
      
      <guid>/post/trouble-with-triples/</guid>
      <description>&lt;p&gt;In the Star Trek episode &amp;ldquo;The Trouble with Tribbles&amp;rdquo; the crew of the starship Enterprise encounters creatures called Tribbles. They are cute, simple creatures of mysterious origin that seem harmless at first but when they multiply the pose a big problem for the ship and the crew.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;/img/post/trouble-with-triples/tribbles.jpg&#34; alt=&#34;Tribbles © 1967 Paramount Pictures&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Tribbles&lt;/h4&gt;
        &lt;p&gt;
        Tribbles © 1967 Paramount Pictures
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Representing and reasoning with knowledge have surprisingly similar problems. A single fact on its own is a relatively straightforward affair. A fact, such as &lt;strong&gt;&amp;ldquo;Tribbles are cute&amp;rdquo;&lt;/strong&gt; can be represented with only three parts of a triple: a subject &lt;strong&gt;Tribbles&lt;/strong&gt;, a predicate &lt;strong&gt;are&lt;/strong&gt; and an object &lt;strong&gt;cute&lt;/strong&gt;. Things can get quite a bit more difficult when there are more facts/triples: &lt;strong&gt;&amp;ldquo;Tribbles are round&amp;rdquo;&lt;/strong&gt;, &lt;strong&gt;&amp;ldquo;Tribbles are furry&amp;rdquo;&lt;/strong&gt;, &lt;strong&gt;&amp;ldquo;Tribbles originate from Iota Geminorum IV&amp;rdquo;&lt;/strong&gt;, and other millions of facts that one could have about such a species. This is especially true when one takes into the account that the fact that knowledge can be interlinked &lt;strong&gt;&amp;ldquo;Iota Geminorum IV is a planet&amp;rdquo;&lt;/strong&gt;,  &lt;strong&gt;&amp;ldquo;Iota Geminorum IV is also known as Fafniri&amp;rdquo;&lt;/strong&gt;, &lt;strong&gt;&amp;ldquo;Iota Geminorum IV is also known as Tribble Prime&amp;rdquo;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;This makes representing and reasoning with facts a non-trivial process. A system that holds all this knowledge should be able to answer a query such as &lt;strong&gt;&amp;ldquo;Do Tribbles originate from Fafniri?&amp;rdquo;&lt;/strong&gt; with a yes, based on the facts &lt;strong&gt;&amp;ldquo;Tribbles originate from Iota Geminorum IV&amp;rdquo;&lt;/strong&gt;, &lt;strong&gt;&amp;ldquo;Iota Geminorum IV is a planet&amp;rdquo;&lt;/strong&gt; and &lt;strong&gt;&amp;ldquo;Iota Geminorum IV is also known as Fafniri&amp;rdquo;&lt;/strong&gt;, even in the context of millions of other triples.&lt;/p&gt;

&lt;p&gt;Another interesting issue with representing facts is the context of the information. To us the viewers, and initially to the crew of the Enterprise, Tribbles look like harmless and adorable creatures. To the Klingons they are an ecological menace and their mortal enemies. How such &amp;ldquo;knowledge about knowledge&amp;rdquo; is represented and used is often a challenging problem.&lt;/p&gt;

&lt;p&gt;Various technologies have been proposed to deal with the above-mentioned issues. &lt;a href=&#34;https://www.w3.org/standards/semanticweb/&#34; target=&#34;_blank&#34;&gt;The Semantic Web technologies&lt;/a&gt; of &lt;a href=&#34;https://www.w3.org/standards/semanticweb/data&#34; target=&#34;_blank&#34;&gt;Linked Data&lt;/a&gt; and &lt;a href=&#34;https://www.w3.org/standards/techs/owl#w3c_all&#34; target=&#34;_blank&#34;&gt;Ontologies&lt;/a&gt; in particular have been designed around solving many of these problems. Nonetheless there is room for improvement. In the future I hope to be able to explain how these techniques can be utilized and perhaps lessen the pain points that currently surround (the use of) them.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>/post/introduction/</link>
      <pubDate>Sun, 14 Jan 2018 00:00:00 +0100</pubDate>
      
      <guid>/post/introduction/</guid>
      <description>&lt;p&gt;Welcome to the first post on my blog on which hopefully many will follow. My intention is to write about knowledge representation, reasoning, AI and coding, in an easily digestible but in depth-way.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
