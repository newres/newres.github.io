<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Newres Al Haider on Newres Al Haider</title>
    <link>https://www.newresalhaider.com/</link>
    <description>Recent content in Newres Al Haider on Newres Al Haider</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Newres Al Haider</copyright>
    <lastBuildDate>Thu, 21 Dec 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Aesopica: part 3</title>
      <link>https://www.newresalhaider.com/post/aesopica-3/</link>
      <pubDate>Tue, 04 Dec 2018 00:00:00 +0100</pubDate>
      
      <guid>https://www.newresalhaider.com/post/aesopica-3/</guid>
      <description>&lt;p&gt;This article is the third part of a series, examining the use of the Clojure language for representing Linked Data, with examples from Aesop&amp;rsquo;s stories. In &lt;a href=&#34;https://www.newresalhaider.com/post/aesopica-1/&#34; target=&#34;_blank&#34;&gt;part one&lt;/a&gt; the basic elements of &amp;ldquo;The Fox and the Stork&amp;rdquo; story were formalised as Linked Data in Clojure, while in &lt;a href=&#34;https://www.newresalhaider.com/post/aesopica-2/&#34; target=&#34;_blank&#34;&gt;part two&lt;/a&gt; we investigated how various literal values can be described. In this article we examine how information about facts themselves, such as meta-information, can be described with Linked Data. As always, the functionality detailed in these articles can be found in the &lt;a href=&#34;https://github.com/newres/aesopica&#34; target=&#34;_blank&#34;&gt;Aesopica&lt;/a&gt; library for using Clojure to write Linked Data.&lt;/p&gt;

&lt;p&gt;In Linked Data, facts are represented as triples of subjects, predicates and objects. For example, when representing the story of the &amp;ldquo;The Fox and the Stork&amp;rdquo; one fact that we want to represent is &amp;ldquo;The Fox gives an invitation.&amp;rdquo; In this fact &amp;ldquo;The Fox&amp;rdquo; is the subject, the &amp;ldquo;gives an&amp;rdquo; is the predicate and &amp;ldquo;an invitation&amp;rdquo; is the object. Of course, as we mentioned in our previous articles, one of the strengths of Linked Data is that the elements are more precisely defined than just their natural language representations in a sentence. A Uniform Resource Identifier (&lt;a href=&#34;https://www.w3.org/wiki/URI&#34; target=&#34;_blank&#34;&gt;URI&lt;/a&gt;) is used to more formally identify these elements. This would make the previous fact to be written as follows, using the Turtle notation of RDF:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rdf&#34;&gt;http://www.newresalhaider.com/ontologies/aesop/foxstork/fox http://www.newresalhaider.com/ontologies/aesop/foxstork/gives-invitation http://www.newresalhaider.com/ontologies/aesop/foxstork/invitation1.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When making using a base prefix for &lt;code&gt;http://www.newresalhaider.com/ontologies/aesop/foxstork/fox&lt;/code&gt; this could be shortened as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rdf&#34;&gt;@base &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/&amp;gt; .
&amp;lt;fox&amp;gt; &amp;lt;gives-invitation&amp;gt; &amp;lt;invitation1&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using our Clojure based notation, that was introduced in the previous articles, we could write this same fact as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;  {::aes/context
   {nil &amp;quot;http://www.newresalhaider.com/ontologies/aesop/foxstork/&amp;quot;}
   ::aes/facts
   #{[:fox :gives-invitation :invitation1]
     }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above-mentioned fact is just one out of many needed to represent the full story of &amp;ldquo;The Fox and the Stork&amp;rdquo;. In most cases a multitude of facts is required to represent the required knowledge. A set of facts, each consisting of subjects, predicates and objects, form a knowledge graph which provides us with a very general, but precise, way to represent knowledge.&lt;/p&gt;

&lt;p&gt;However there are scenarios when we want to represent knowledge about the facts themselves. One way Linked Data/RDF facilities this is the use of the &amp;ldquo;named graphs&amp;rdquo;. Named graphs allows us to associate an identifier (a &lt;a href=&#34;Uniform Resource Identifier&#34; target=&#34;_blank&#34;&gt;URI&lt;/a&gt;) with a fact, or a set of facts. This essentially gives a name to a graph in the knowledge base, hence the notion of &amp;ldquo;named graphs&amp;rdquo;. Such an identifier can then be used as a way to add information about the facts with which it is associated.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.w3.org/TR/n-quads/&#34; target=&#34;_blank&#34;&gt;NQUADS&lt;/a&gt; syntax for RDF illustrates one way such named graphs can be represented. In this representation all the elements of the fact: the subject, predicate, object and optionally a graph-name, are written out fully, separated by spaces and concluding with a dot (&lt;code&gt;.&lt;/code&gt;) .&lt;/p&gt;

&lt;p&gt;To take a single fact as an example, here follows a NQUADS format representation that details that &amp;ldquo;for the first invitation the Stork has been invited&amp;rdquo;, and this fact is part of the &amp;ldquo;first dinner&amp;rdquo; named graph:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rdf&#34;&gt;&amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/invitation1&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/has-invited&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/stork&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/dinner1&amp;gt; .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For this fact there are four elements to be represented, hence we can refer to these elements together as a quad, versus the notion of a triple for facts just consisting of a subject, predicate and object. As mentioned previously, URIs are used to precisely identify each element:  &lt;code&gt;&amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/invitation1&amp;gt;&lt;/code&gt; is the subject, &lt;code&gt;&amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/has-invited&amp;gt;&lt;/code&gt; is the predicate and &lt;code&gt;&amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/stork&amp;gt;&lt;/code&gt; is the object respectively. In addition the graph is identified by the URI &lt;code&gt;&amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/dinner1&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The big benefit of using such identifiers as names for the graphs is that they themselves can be part of facts. For example if we want to express that the facts contained inside the &amp;ldquo;first dinner&amp;rdquo; graph occur before the facts of the &amp;ldquo;second dinner&amp;rdquo; graph, we can use the fact:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rdf&#34;&gt;&amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/dinner1&amp;gt; &amp;lt;http://www.w3.org/2006/time#before&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/dinner2&amp;gt; .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this fact itself is not part of any named graph. In a knowledge base of facts this would make it a part of the &amp;ldquo;default graph&amp;rdquo;. A default graph is a graph without any particular name. This makes the mixing of &amp;ldquo;regular&amp;rdquo; facts, where each fact consists of a triple, and facts in explicit named graphs, where each fact is a quad, possible in a single knowledge base.&lt;/p&gt;

&lt;p&gt;An example of a sightly expanded version using of &amp;ldquo;The Fox and the Stork&amp;rdquo;&amp;rdquo; story using named graphs in the NQUADS format can be therefor be as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rdf&#34;&gt;&amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/fox&amp;gt; &amp;lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/animal&amp;gt; .
&amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/dinner1&amp;gt; &amp;lt;http://www.w3.org/2006/time#before&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/dinner2&amp;gt; .
&amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/stork&amp;gt; &amp;lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/animal&amp;gt; .
&amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/invitation2&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/serves-using&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/narrow-mouthed-jug&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/dinner2&amp;gt; .
&amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/invitation2&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/has-food&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/crumbled-food&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/dinner2&amp;gt; .
&amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/invitation2&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/has-invited&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/fox&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/dinner2&amp;gt; .
&amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/stork&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/gives-invitation&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/invitation2&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/dinner2&amp;gt; .
&amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/invitation1&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/serves-using&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/narrow-mouthed-jug&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/dinner2&amp;gt; .
&amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/fox&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/gives-invitation&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/invitation1&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/dinner1&amp;gt; .
&amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/invitation1&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/has-food&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/soup&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/dinner1&amp;gt; .
&amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/invitation1&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/serves-using&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/shallow-plate&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/dinner1&amp;gt; .
&amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/invitation1&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/has-invited&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/stork&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/dinner1&amp;gt; .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we introduced the concept of &amp;ldquo;named graphs&amp;rdquo; we now want introduce a way to represent them in the Clojure representation of Linked Data. Similarly on how in NQUADS the triples are extended to quads to indicate the name of the graph, we extend our &lt;a href=&#34;https://www.newresalhaider.com/post/aesopica-1/&#34; target=&#34;_blank&#34;&gt;previously introduced Clojure syntax&lt;/a&gt; to be able to use quads for facts, as opposed to just triples. Similarly to NQUADS the, optional, fourth element of each fact represents the named graph identifier. Any regular triple based fact is part of the default graph in the knowledge base, similarly to the NQUAD representation.&lt;/p&gt;

&lt;p&gt;The resulting Clojure representation of above-mentioned Linked Data story can be written as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def fox-and-stork-named-graph-edn
  {::aes/context
   {nil &amp;quot;http://www.newresalhaider.com/ontologies/aesop/foxstork/&amp;quot;
    :rdf &amp;quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&amp;quot;
    :time &amp;quot;http://www.w3.org/2006/time#&amp;quot;}
   ::aes/facts
   #{[:fox :rdf/type :animal]
     [:stork :rdf/type :animal]
     [:fox :gives-invitation :invitation1 :dinner1]
     [:invitation1 :has-invited :stork :dinner1]
     [:invitation1 :has-food :soup :dinner1]
     [:invitation1 :serves-using :shallow-plate :dinner1]
     [:stork :gives-invitation :invitation2 :dinner2]
     [:invitation2 :has-invited :fox :dinner2]
     [:invitation2 :has-food :crumbled-food :dinner2]
     [:invitation2 :serves-using :narrow-mouthed-jug :dinner2]
     [:invitation1 :serves-using :narrow-mouthed-jug :dinner2]
     [:dinner1 :time/before :dinner2]}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main difference between the Clojure representation and NQUADS is that the Clojure representation uses prefixes and NQUADS uses full URIs written out each time. This is a deliberate design choice in syntax from both perspectives. In NQUADS this allows the format to represent each fact on a single line, without the need for a lookup based on context for the full URI of elements. In the Clojure representation the prefixes allow for a much more compact fact representation that makes for easier reading and writing by human users.&lt;/p&gt;

&lt;p&gt;There are a number of other formats for writing Linked Data, some of which support named graphs. &lt;a href=&#34;https://www.w3.org/TR/trig/&#34; target=&#34;_blank&#34;&gt;TriG&lt;/a&gt; for example is an extension of the Turtle format used in previous articles in this series. &lt;a href=&#34;https://json-ld.org/&#34; target=&#34;_blank&#34;&gt;JSON-LD&lt;/a&gt; is also a very commonly used format for Linked Data that also supports named graphs. With the introduction of the Clojure way of writing Linked Data in this series, it makes sense to enable translating Linked Data into these formats for compatibility and reaching a wider audience. The facts on how to achieve this will be detailed in another article.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Aesopica: part 2</title>
      <link>https://www.newresalhaider.com/post/aesopica-2/</link>
      <pubDate>Fri, 14 Sep 2018 00:00:00 +0200</pubDate>
      
      <guid>https://www.newresalhaider.com/post/aesopica-2/</guid>
      <description>&lt;p&gt;This article is the second part of a series, examining the use of the Clojure language for representing Linked Data, with examples from Aesop&amp;rsquo;s stories. Part one can be found &lt;a href=&#34;https://www.newresalhaider.com/post/aesopica-1/&#34; target=&#34;_blank&#34;&gt;on this site&lt;/a&gt; where the basic elements of the Fox and the Stork story were formalised. In this article we examine how literal values can be represented, using Clojure, in Linked Data. The code to enable the functionality described in these articles can be found in the &lt;a href=&#34;https://github.com/newres/aesopica&#34; target=&#34;_blank&#34;&gt;Aesopica&lt;/a&gt; library for using Clojure to write Linked Data.&lt;/p&gt;

&lt;p&gt;As mentioned in the previous article the story of the Fox and the Stork is about the fox who invited the stork for a dinner. At the dinner soup was served from a shallow plate that the fox could eat but the stork could not. In return, the stork invited the fox to a dinner, where the food was served in a narrow mouthed jug. This time the fox could not reach the food, while the stork ate it happily.&lt;/p&gt;

&lt;p&gt;Elements of this story can be represented as &lt;a href=&#34;https://www.w3.org/standards/semanticweb/data&#34; target=&#34;_blank&#34;&gt;Linked Data&lt;/a&gt;, and in particular the &lt;a href=&#34;https://www.w3.org/RDF/&#34; target=&#34;_blank&#34;&gt;Resource Description Framework (RDF)&lt;/a&gt; that allows for a precise retelling of the story that is understandable to both humans and machines alike.&lt;/p&gt;

&lt;p&gt;For example, the part of the Linked Data we generated in the previous article is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rdf&#34;&gt;@base &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/&amp;gt; .
@prefix rdf: &amp;lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&amp;gt; .

&amp;lt;fox&amp;gt; rdf:type &amp;lt;animal&amp;gt;.
&amp;lt;stork&amp;gt; rdf:type &amp;lt;animal&amp;gt;.
&amp;lt;fox&amp;gt; &amp;lt;gives-invitation&amp;gt; &amp;lt;invitation1&amp;gt;.
&amp;lt;invitation1&amp;gt; &amp;lt;has-invited&amp;gt; &amp;lt;stork&amp;gt;.
&amp;lt;invitation1&amp;gt; &amp;lt;has-food&amp;gt; &amp;lt;soup&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which details the elements of the story that the fox invites the stork, where soup is served. Elements that might be implicitly obvious to a human reader, but not to a program, that the fox and the stork are animals, are also represented in this fragment. These elements are describes as a set of facts, where each fact is a triple in the form of a subject, predicate and object. Each part of these facts in this example are represented as a &lt;a href=&#34;https://en.wikipedia.org/wiki/Uniform_Resource_Identifier&#34; target=&#34;_blank&#34;&gt;Uniform Resource Identifier (URI)&lt;/a&gt;, which are shortened with prefixes (i.e. &lt;code&gt;&amp;quot;rdf&amp;quot;&lt;/code&gt;) or the base URI (i.e. &lt;code&gt;&amp;lt;fox&amp;gt;&lt;/code&gt; is a shorthand for &lt;code&gt;http://www.newresalhaider.com/ontologies/aesop/foxstork/fox&lt;/code&gt; ).&lt;/p&gt;

&lt;p&gt;Now suppose we want to expand on the elements of this story. For example, we want to give the fox and the stork a name, an age, describe their personalities, give a time for the dinners, etc. For many of these elements we want to simply use value as objects in the representations. For example the number &lt;code&gt;2&lt;/code&gt; as a representative of the age of the fox. In such scenarios we do not use URIs in the facts but &lt;a href=&#34;https://www.w3.org/TR/rdf11-concepts/#section-Graph-Literal&#34; target=&#34;_blank&#34;&gt;Literals&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Literals can be used to denote numbers, strings, dates and other such elements. In the Linked Data representation below we describe various attributes of the fox, the stork and the dinner with such literals.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rdf&#34;&gt;@base &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/&amp;gt; .
  @prefix rdf: &amp;lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&amp;gt; .
  @prefix foaf: &amp;lt;http://xmlns.com/foaf/0.1/&amp;gt; .
  @prefix xsd: &amp;lt;http://www.w3.org/2001/XMLSchema#&amp;gt;.

  &amp;lt;fox&amp;gt; rdf:type &amp;lt;animal&amp;gt;.
  &amp;lt;fox&amp;gt; foaf:name &amp;quot;vo&amp;quot;.
  &amp;lt;fox&amp;gt; foaf:age 2.
  &amp;lt;fox&amp;gt; &amp;lt;is-cunning&amp;gt; true.
  &amp;lt;stork&amp;gt; rdf:type &amp;lt;animal&amp;gt;.
  &amp;lt;stork&amp;gt; foaf:name &amp;quot;ooi&amp;quot;.
  &amp;lt;stork&amp;gt; foaf:age 13.
  &amp;lt;stork&amp;gt; &amp;lt;is-cunning&amp;gt; true.
  &amp;lt;dinner1&amp;gt; &amp;lt;has-date&amp;gt; &amp;quot;2006-06-30T20:00:00&amp;quot;^^xsd:dateTime
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As one can see in this example, representing literals is very similar to other objects. For example &lt;code&gt;&amp;quot;vo&amp;quot;&lt;/code&gt; in the triple &lt;code&gt;&amp;lt;fox&amp;gt; foaf:name &amp;quot;vo&amp;quot;&lt;/code&gt; represents the name of the fox. Note that the base of &lt;code&gt;foaf&lt;/code&gt; in &lt;code&gt;foaf:name&lt;/code&gt; and &lt;code&gt;foaf:age&lt;/code&gt; refers to the &amp;lsquo;Friend of a Friend&amp;rsquo; ontology, that allows us to use the common terminology of this ontology to describe facts about the fox and the stork.  Literals such as &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;true&lt;/code&gt; describe the age, and whether the fox is cunning, respectively. These are called the lexical forms of the literals and while they also have explicit types (e.g. &lt;code&gt;http://www.w3.org/2001/XMLSchema#string&lt;/code&gt; or simply &lt;code&gt;xsd:string&lt;/code&gt; when using prefixes ), these types of literals are so common that writing the types explicitly is not required.&lt;/p&gt;

&lt;p&gt;The slightly more complicated case is the definition of the time of the dinner shown by &lt;code&gt;&amp;quot;2006-06-30T20:00:00&amp;quot;^^xsd:dateTime&lt;/code&gt; that shows off custom types for literals, or when we would like to give the type explicitly. Here the addition of the &lt;code&gt;^^xsd:dateTime&lt;/code&gt; is an URI (with a prefix) describing how lexical form, i.e. &amp;ldquo;2006-06-30T20:00:00&amp;rdquo; exactly maps to a particular value. This allows for easier interpretation of such literal values for machines.&lt;/p&gt;

&lt;p&gt;As in the previous article, we aim to use the data representation and manipulation capabilities of Clojure to represent the above-mentioned fragment. Again, for the basic cases, such as strings, numbers, etc, we can be pretty straightforward and only use the lexical form, i.e. &lt;code&gt;&amp;quot;vo&amp;quot;&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;true&lt;/code&gt; in or representations. For the cases where we also want to specify a custom datatype, we use a map such as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;{:value &amp;quot;2006-06-30T20:00:00&amp;quot; :type :xsd/dateTime}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where the keys &lt;code&gt;:value&lt;/code&gt; and &lt;code&gt;:type&lt;/code&gt; are representing the lexical form and datatype respectively. To full Clojure version of this example can be found below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;  {::aes/context
   {nil &amp;quot;http://www.newresalhaider.com/ontologies/aesop/foxstork/&amp;quot;
    :rdf &amp;quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&amp;quot;
    :foaf &amp;quot;http://xmlns.com/foaf/0.1/&amp;quot;
    :xsd &amp;quot;http://www.w3.org/2001/XMLSchema#&amp;quot;}
   ::aes/facts
   #{[:fox :rdf/type :animal]
     [:fox :foaf/name &amp;quot;vo&amp;quot;]
     [:fox :foaf/age 2]
     [:fox :is-cunning true]
     [:fox :has-weight 6.8]
     [:stork :rdf/type :animal]
     [:stork :foaf/name &amp;quot;ooi&amp;quot;]
     [:stork :foaf/age 13]
     [:stork :is-cunning true]
     [:dinner1 :has-date {:value &amp;quot;2006-06-30T20:00:00&amp;quot; :type :xsd/dateTime}]}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course given that this story is centuries old, it is unlikely that the dinner took place at &lt;code&gt;2006-06-30T20:00:00&lt;/code&gt;. As always care must be taken when taking things literally.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Aesopica: part 1</title>
      <link>https://www.newresalhaider.com/post/aesopica-1/</link>
      <pubDate>Mon, 10 Sep 2018 00:00:00 +0200</pubDate>
      
      <guid>https://www.newresalhaider.com/post/aesopica-1/</guid>
      <description>

&lt;p&gt;The stories called Aesop&amp;rsquo;s Fables or the Aesopica, are an ancient collection of stories that have been passed down to modern day. These stories are of diverse origins they cover a wide variety of themes. Although originally intended for an adult audience, in later times were often used for the education of children.&lt;/p&gt;

&lt;p&gt;One of such stories is the tale of the Fox and the Stork. There are many versions of this fable, but the overall outline is generally as follows:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;The fox invited the stork to dinner. At the dinner soup was served from a shallow plate, that the fox could eat but the hungry stork could not even taste. In turn the stork invited the fox to a dinner. Dinner was served in a narrow mouthed jug filled with crumbled food. This time the fox could not reach the food, while the stork ate.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;figure&gt;
    
        &lt;img src=&#34;https://www.newresalhaider.com/img/post/2018-09/aesopica-1/foxandstork.jpeg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;A 1884 fountain design depicting the story of the Fox and the Stork by Catalan sculptor Eduard Batiste Alentorn in Barcelona&lt;/h4&gt;
        &lt;p&gt;
        
        &lt;a href=&#34;https://commons.wikimedia.org/w/index.php?curid=25764300&#34;&gt; 
            By Jordiferrer - Own work, CC BY-SA 3.0
        &lt;/a&gt; 
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;The intention of stories such as these, as well as text in general, is to convey meaning. However, in addition to humans, a new audience for text has come to light in recent years: machines. To facilitate this new audience a set of technologies has been developed to convey the meaning of text in a precise and unambiguous way that is easily understandable for both humans and machines alike. Many of these new methods fall under the umbrella of the &lt;a href=&#34;https://www.w3.org/standards/semanticweb/&#34; target=&#34;_blank&#34;&gt;Semantic Web&lt;/a&gt;. The goal of the Semantic Web is to create a web of data where the meaning of the information is both human and machine understandable.&lt;/p&gt;

&lt;p&gt;One of the cornerstone technologies in conveying information for this purpose is &lt;a href=&#34;https://www.w3.org/standards/semanticweb/data&#34; target=&#34;_blank&#34;&gt;Linked Data&lt;/a&gt;, and in particular the &lt;a href=&#34;https://www.w3.org/RDF/&#34; target=&#34;_blank&#34;&gt;Resource Description Framework (RDF)&lt;/a&gt; standard that defines how this Linked Data can be expressed. I have written a &lt;a href=&#34;https://www.newresalhaider.com/post/interlinked-data/&#34; target=&#34;_blank&#34;&gt;short introduction to Linked Data&lt;/a&gt; before but to summarize: it allows for the expressing information as a set of facts. These facts have the form of subject, predicate, object triples. A set of these facts is often called a knowledge base, or in an alternative view this can also been seen as a knowledge graph where the facts define the nodes and edges.&lt;/p&gt;

&lt;p&gt;In a Linked Data representation the story of Fox and the Stork would look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rdf&#34;&gt;@base &amp;lt;http://www.newresalhaider.com/ontologies/aesop/foxstork/&amp;gt; .
@prefix rdf: &amp;lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&amp;gt; .

&amp;lt;fox&amp;gt; rdf:type &amp;lt;animal&amp;gt;.
&amp;lt;stork&amp;gt; rdf:type &amp;lt;animal&amp;gt;.
&amp;lt;fox&amp;gt; &amp;lt;gives-invitation&amp;gt; &amp;lt;invitation1&amp;gt;.
&amp;lt;invitation1&amp;gt; &amp;lt;has-invited&amp;gt; &amp;lt;stork&amp;gt;.
&amp;lt;invitation1&amp;gt; &amp;lt;has-food&amp;gt; &amp;lt;soup&amp;gt;.
&amp;lt;invitation1&amp;gt; &amp;lt;serves-using&amp;gt; &amp;lt;shallow-plate&amp;gt;.
&amp;lt;stork&amp;gt; &amp;lt;gives-invitation&amp;gt; &amp;lt;invitation2&amp;gt;.
&amp;lt;invitation2&amp;gt; &amp;lt;has-invited&amp;gt; &amp;lt;fox&amp;gt;.
&amp;lt;invitation2&amp;gt; &amp;lt;has-food&amp;gt; &amp;lt;crumbled-food&amp;gt;.
&amp;lt;invitation2&amp;gt; &amp;lt;serves-using&amp;gt; &amp;lt;narrow-mouthed-jug&amp;gt;.
&amp;lt;fox&amp;gt; &amp;lt;can-eat-food-served-using&amp;gt; &amp;lt;shallow-plate&amp;gt;.
&amp;lt;fox&amp;gt; &amp;lt;can-not-eat-food-served-using&amp;gt; &amp;lt;narrow-mouthed-jug&amp;gt;.
&amp;lt;stork&amp;gt; &amp;lt;can-eat-food-served-using&amp;gt; &amp;lt;narrow-mouthed-jug&amp;gt;.
&amp;lt;stork&amp;gt; &amp;lt;can-not-eat-food-served-using&amp;gt; &amp;lt;shallow-plate&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is in the &lt;a href=&#34;https://www.w3.org/TR/turtle/&#34; target=&#34;_blank&#34;&gt;Turtle syntax&lt;/a&gt; of RDF. There are other types of syntax are available to represent Linked Data, for example in JSON form as &lt;a href=&#34;https://www.w3.org/TR/json-ld/&#34; target=&#34;_blank&#34;&gt;JSON-LD&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To summarize a bit of what this Linked Data format does in this scenario, is that it uses &lt;a href=&#34;https://en.wikipedia.org/wiki/Uniform_Resource_Identifier&#34; target=&#34;_blank&#34;&gt;Uniform Resource Identifiers (URIs)&lt;/a&gt; to define the subjects, predicates and objects of each fact. This allows to precisely and unambiguously define and link the meaning between these elements. For example, the fact that the fox is a type of animal could be expressed by the triple with the full URIs: &lt;code&gt;http://www.newresalhaider.com/ontologies/aesop/foxstork/fox http://www.w3.org/1999/02/22-rdf-syntax-ns#type http://www.newresalhaider.com/ontologies/aesop/foxstork/animal .&lt;/code&gt; Due to the fact that writing the full URIs can be quite cumbersome, the Turtle syntax uses two kinds of shorthands to help out. In this case one can define a base URI for the current document, &lt;a href=&#34;http://www.newresalhaider.com/ontologies/aesop/foxstork&#34; target=&#34;_blank&#34;&gt;http://www.newresalhaider.com/ontologies/aesop/foxstork&lt;/a&gt;, as well as prefixes for other namespeaces, such as &lt;a href=&#34;http://www.w3.org/1999/02/22-rdf-syntax-ns#&#34; target=&#34;_blank&#34;&gt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&lt;/a&gt;, with which the writing of each fact that would begin with these URI fragments could be shortened.&lt;/p&gt;

&lt;p&gt;When everything put together this format still describes the original story, albeit restructured into separate facts.&lt;/p&gt;

&lt;p&gt;There exists many tools for handling Linked Data such as the above story. For example APIs, such as &lt;a href=&#34;https://jena.apache.org/&#34; target=&#34;_blank&#34;&gt;Jena&lt;/a&gt;, can aid in the creation, storage and querying of data made available in such a fashion. Of course more and better tools and techniques are always welcome. In this article in particular we hope to describe how we can use the Clojure programming language to enable working with Linked Data.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://clojure.org/&#34; target=&#34;_blank&#34;&gt;Clojure&lt;/a&gt; is a language that offers a lot of benefits. The focus on manipulating pure data, with immutable data-structures and functional programming, provides an excellent way to organize code. The ability to inter-operate with the Java and JavaScript ecosystems, allows for the use of many mature libraries as well as many avenues for deployment.&lt;/p&gt;

&lt;p&gt;To use the data manipulation capabilities of Clojure to enable the Semantic Web, seems like a natural combination. Some previous works also aimed at exploring this area, notably &lt;a href=&#34;https://github.com/ontodev/edn-ld&#34; target=&#34;_blank&#34;&gt;EDN-LD&lt;/a&gt; which gives a convention and a library for working with Linked Data.&lt;/p&gt;

&lt;p&gt;In this article we will also explore how we can use Clojure to interact with Linked Data. In our case we will focus on the creation Linked Data from a Clojure environment and we might take different conventions compared to previous work, so we start with a fresh implementation.&lt;/p&gt;

&lt;p&gt;In Clojure, information is directly represented as data, as opposed to it being encapsulated into various other abstractions such as objects. A large subset of elements data in Clojure is also a data format called &lt;a href=&#34;https://github.com/edn-format/edn&#34; target=&#34;_blank&#34;&gt;the Extensible Data Notation (EDN)&lt;/a&gt;. The built-in elements in this notation are nil, booleans, strings, characters, symbols, keywords, integers, floating-point numbers, lists, vectors, maps and sets. The meaning behind most of these elements is relatively straightforward, so we only give a brief summary of them here and some examples.&lt;/p&gt;

&lt;h5 id=&#34;nil&#34;&gt;Nil&lt;/h5&gt;

&lt;p&gt;An empty or non-existent element is represented by &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id=&#34;booleans&#34;&gt;Booleans&lt;/h5&gt;

&lt;p&gt;A boolean value can be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id=&#34;strings&#34;&gt;Strings&lt;/h5&gt;

&lt;p&gt;Strings are written in double quotes, for example: &lt;code&gt;&amp;quot;This sentence is a string.&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id=&#34;characters&#34;&gt;Characters&lt;/h5&gt;

&lt;p&gt;Characters representing single characters, and are preceded by a backslash, for example &lt;code&gt;\c&lt;/code&gt; or &lt;code&gt;\newline&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id=&#34;symbols&#34;&gt;Symbols&lt;/h5&gt;

&lt;p&gt;Symbols are representing identifiers, written by a set of characters (with a few additional rules). Examples of identifiers are for example &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;clojure.core&lt;/code&gt;, &lt;code&gt;clojure.string/split&lt;/code&gt;. As some of these examples show, in Clojure they are used, among other things to refer to modules and functions. Another interesting feature, as the &lt;code&gt;clojure.string/split&lt;/code&gt; example shows, is that they can be namespaced which helps to organize symbols and avoid name collisions.&lt;/p&gt;

&lt;h5 id=&#34;keywords&#34;&gt;Keywords&lt;/h5&gt;

&lt;p&gt;Keywords are very similar to symbols but they are identifiers that refer to themselves. They are constructed much like symbols, but with a leading &lt;code&gt;:&lt;/code&gt;. Examples of keywords are &lt;code&gt;:fruit&lt;/code&gt; or &lt;code&gt;:company.persons/name&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id=&#34;integers-and-floats&#34;&gt;Integers and Floats&lt;/h5&gt;

&lt;p&gt;Integers and floats (floating point numbers) are used, as expected, to write numbers &lt;code&gt;3&lt;/code&gt; or &lt;code&gt;4.5&lt;/code&gt; for example.&lt;/p&gt;

&lt;p&gt;All these elements described above can be put in collections.&lt;/p&gt;

&lt;h5 id=&#34;lists&#34;&gt;Lists&lt;/h5&gt;

&lt;p&gt;Lists are a sequence of values enclosed in &lt;code&gt;()&lt;/code&gt;, for example &lt;code&gt;(2 &amp;quot;A string.&amp;quot; false)&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id=&#34;vectors&#34;&gt;Vectors&lt;/h5&gt;

&lt;p&gt;Vectors are a sequence of values enclosed in &lt;code&gt;[]&lt;/code&gt;, for example &lt;code&gt;[true nil :company/name]&lt;/code&gt;. which are designed for random access of its elements.&lt;/p&gt;

&lt;h5 id=&#34;sets&#34;&gt;Sets&lt;/h5&gt;

&lt;p&gt;Sets are collections of unique values enclosed in &lt;code&gt;#{}&lt;/code&gt;, such as &lt;code&gt;#{:fruit 2}&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id=&#34;maps&#34;&gt;Maps&lt;/h5&gt;

&lt;p&gt;Finally maps are key value pairs, enclosed in curly braces &lt;code&gt;{}&lt;/code&gt;, for example &lt;code&gt;{:name &amp;quot;John Smith&amp;quot;, :age 4}&lt;/code&gt;, where each key is unique. Of course collections can also nested any type of collection.&lt;/p&gt;

&lt;p&gt;Using this notation elements of EDN, we can build an EDN based version of the story of the Fox and the Stork, using some conventions.&lt;/p&gt;

&lt;p&gt;Given that in many practical cases we are probably going to shorten URIs with prefixes when writing, we can use a keyword for denoting elements. In the case where we would use the base prefix, we can just use a regular, non-namespaced, keyword, i.e. &lt;code&gt;:fox&lt;/code&gt;, and in cases where we would refer to any other prefix we can use namespaced keywords, i.e. &lt;code&gt;:rdf/type&lt;/code&gt;. A full fact could then be described with a relatively straightforward vector, for example &lt;code&gt;[:fox :rdf/type :animal]&lt;/code&gt; and the knowledge base with a set of facts such as &lt;code&gt;#{[:fox :rdf/type :animal] [:stork :rdf/type :animal]}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Of course this means that in addition to facts we also need some data for the context, in which we store the base and other prefixes and to what they map to, to be able to fully build an equivalent Linked Data representation. The context will be a map of the relevant prefixes as keys, as well as nil for the base prefix. For the above example this means that the below example will describe the context needed to resolve all the full URIs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;{nil &amp;quot;http://www.newresalhaider.com/ontologies/aesop/foxstork/&amp;quot;
:rdf &amp;quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Putting everything together, to have a full Linked Data graph we need a context and a set of facts, so the overall structure will be a map where these are both defined:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;  {::aes/context
   {nil &amp;quot;http://www.newresalhaider.com/ontologies/aesop/foxstork/&amp;quot;
    :rdf &amp;quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&amp;quot;}
   ::aes/facts
   #{[:fox :rdf/type :animal]
     [:stork :rdf/type :animal]
     [:fox :gives-invitation :invitation1]
     [:invitation1 :has-invited :stork]
     [:invitation1 :has-food :soup]
     [:invitation1 :serves-using :shallow-plate]
     [:stork :gives-invitation :invitation2]
     [:invitation2 :has-invited :stork]
     [:invitation2 :has-food :crumbled-food]
     [:invitation2 :serves-using :narrow-mouthed-jug]
     [:fox :can-eat-food-served-using :shallow-plate]
     [:fox :can-not-eat-food-served-suing :narrow-mouthed-jug]
     [:stork :can-eat-food-served-using :narrow-mouthed-jug]
     [:stork :can-not-eat-food-served-suing :shallow-plate]}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have started a small library for manipulating Linked Data structures written this way, with the name &lt;a href=&#34;https://github.com/newres/aesopica&#34; target=&#34;_blank&#34;&gt;aesopica&lt;/a&gt;. It is in very early stages, where the current main functionality is to translate Linked Data written this way into the Turtle format described above.&lt;/p&gt;

&lt;p&gt;Of course there are lot of other elements of Linked Data that needs to be represented in this that we did not tackle yet. In addition there are also a large number of Clojure libraries that could be used to make writing and using Linked Data in this fashion easier. How these features could be achieved however is a story for another time.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Excavating a Common Treasure</title>
      <link>https://www.newresalhaider.com/post/common-treasure/</link>
      <pubDate>Sat, 30 Jun 2018 00:00:00 +0200</pubDate>
      
      <guid>https://www.newresalhaider.com/post/common-treasure/</guid>
      <description>&lt;p&gt;History is full of legends of ancient treasures and powerful artifacts, lost to time or hidden by purpose, that would bring glory, power and riches to their discoverer.&lt;/p&gt;


&lt;figure&gt;
    
        &lt;img src=&#34;https://www.newresalhaider.com/img/post/2018-06/common-treasure/winged-bull.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;A winged bull depicted on an on archaeological artifact from the Assyrian empire between 1400 and 1200 BC. Cylinder Seal with Winged Bull - Walters Art Museum Licensed under CC0.&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Although the history of software development is much shorter than the history of mankind, there already exists artifacts that have near mythological status when it comes to software development, yet often go hidden underneath the surface. One of these is the language of Common Lisp.&lt;/p&gt;

&lt;p&gt;Common Lisp is a language originally from the early 80s, and was a standardization of many dialects of the Lisp programming language, which explains both the Common and Lisp part of the name. Lisp itself is one of the oldest general purpose programming languages, first specified in 1958. From Lisp many ideas that we consider common in other languages were popularized, such as conditionals (the &lt;code&gt;if and else&lt;/code&gt; structure), notion of functions as first class elements, and many others (see this &lt;a href=&#34;http://www.paulgraham.com/diff.html&#34; target=&#34;_blank&#34;&gt;article&lt;/a&gt; on more of these ideas). Common Lisp is also often &lt;a href=&#34;http://www.gigamonkeys.com/book/introduction-why-lisp.html&#34; target=&#34;_blank&#34;&gt;mentioned&lt;/a&gt; as an amazing and fun language to learn, which makes it the clear-cut choice for this article.&lt;/p&gt;

&lt;p&gt;As the story goes it gives the user untold levels of productivity and joy of development. One other big advantage is that Common Lisp used to be the language of A.I. research. There is lots of existing code out there for systems on the subject of knowledge representation, reasoning and planning. Given the resurgence of fields such as a &lt;a href=&#34;https://www.w3.org/standards/semanticweb/&#34; target=&#34;_blank&#34;&gt;Semantic Web&lt;/a&gt; that make use of such A.I. systems, learning from such tools and techniques, or even using them directly, can be invaluable. In this post, I aim to find out a very small portion of the riches we can dig up using Common Lisp, and to share this experience with the reader.&lt;/p&gt;


&lt;figure&gt;
    
        &lt;img src=&#34;https://www.newresalhaider.com/img/post/2018-06/common-treasure/seal.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Cylinder Seals were common objects that were used to designate ownership in ancient Mesopotamia. Although describing to a different notion of &amp;#39;common&amp;#39; these show remarkable of craftsmanship that we hope to introduce ourselves to in Common Lisp. Cylinder Seal with Two Heroes and a Tree - Walters Art Museum Licensed under CC0.&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;To add as a disclamer, I do have experience with a similar language, &lt;a href=&#34;https://clojure.org/&#34; target=&#34;_blank&#34;&gt;Clojure&lt;/a&gt; that I use in my day-to-day programming, as well as with &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34; target=&#34;_blank&#34;&gt;Emacs&lt;/a&gt; (namely &lt;a href=&#34;http://spacemacs.org/&#34; target=&#34;_blank&#34;&gt;Spacemacs&lt;/a&gt;), so I probably have some head start in using and editing the language. Nonethess I aim to make this introduction accessible to readers without such knowledge.&lt;/p&gt;

&lt;p&gt;With any treasure hunt, preparation is often key. As we are unfamiliar with the language itself it is good to read guides and tutorials to prepare. The guide to selecting the right equipment for our adventure is the &lt;a href=&#34;https://lispcookbook.github.io/cl-cookbook/getting-started.html&#34; target=&#34;_blank&#34;&gt;cl-cookbook&lt;/a&gt;, which describes how to get started with Common Lisp.&lt;/p&gt;

&lt;p&gt;Common Lisp is a language with multiple implementations. As recommended by our guide we are using &lt;a href=&#34;http://www.sbcl.org/&#34; target=&#34;_blank&#34;&gt;Steel Bank Common Lisp (SBCL)&lt;/a&gt; as distribution and using &lt;a href=&#34;https://github.com/roswell/roswell/wiki&#34; target=&#34;_blank&#34;&gt;Roswell&lt;/a&gt; to manage it. Alternatively a more straightforward install is &lt;a href=&#34;https://portacle.github.io/&#34; target=&#34;_blank&#34;&gt;Portacle&lt;/a&gt; that could be used.&lt;/p&gt;

&lt;p&gt;Next is testing whether our implementation is working. We run the Read–Eval–Print Loop (REPL), which in the case of Roswell can be done with the command &lt;code&gt;ros run&lt;/code&gt;. What the REPL allows us to do is interactively develop our code by reading our input, evaluating it and printing the results. This is one of the many features in programming that originated with Lisp, but has since made its way to many other languages.&lt;/p&gt;

&lt;p&gt;Now the question is how we should write Common Lisp. One really nice resource for quickly familiarizing with new languages is Learn X in Y minutes, which also has a nice &lt;a href=&#34;https://learnxinyminutes.com/docs/common-lisp/&#34; target=&#34;_blank&#34;&gt;introduction to Common Lisp&lt;/a&gt;. One of the most striking features of a Lisp, is the syntax of it. Elements are either atoms, that evaluate to themselves, such as the number &lt;code&gt;4&lt;/code&gt; or s-expressions which are a list of expressions in brackets, such as &lt;code&gt;(+ 3 2)&lt;/code&gt;. Atoms evaluate to themselves, so if we write &lt;code&gt;4&lt;/code&gt; in the REPL, we get &lt;code&gt;4&lt;/code&gt; returned back. For s-expressions they are in the form of &lt;code&gt;(function param1 param2 ...)&lt;/code&gt;, so in the case of &lt;code&gt;(+ 3 2)&lt;/code&gt; this will evaluate to &lt;code&gt;5&lt;/code&gt;. One can of course nest these forms, for example &lt;code&gt;(+ 3 (+ 3 2))&lt;/code&gt; will result in &lt;code&gt;8&lt;/code&gt;. In addition to functions there are macros available creating completely different forms to be translated into code. We will see some examples of this later in the article.&lt;/p&gt;

&lt;p&gt;With the REPL now working it is time to set up a project where we can write down all the code we need for our digging. According to our cookbook tutorial we can do this from the REPL, by getting &lt;a href=&#34;https://github.com/fukamachi/cl-project&#34; target=&#34;_blank&#34;&gt;cl-project&lt;/a&gt;, and using it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(ql:quickload &amp;quot;cl-project&amp;quot;)
(cl-project:make-project #P&amp;quot;./common-treasure&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will give us the outline of project in the &lt;code&gt;common-treasure&lt;/code&gt; directory. The files generated include a readme, systems for the project itself as well as tests and of course some skeletons for a test and a package itself respectively.&lt;/p&gt;

&lt;p&gt;First we are going to start off figuring out the package itself. Like in many other languages, functionality can be grouped together units, in this case packages. The generated file outline looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defpackage common-treasure
  (:use :cl))
(in-package :common-treasure)

;; blah blah blah.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the looks of it, it says to us that it defines a package named &lt;code&gt;common-treasure&lt;/code&gt; using &lt;code&gt;:cl&lt;/code&gt;, which I assume is another package. There is also a call to &lt;code&gt;in-package&lt;/code&gt; which looks like is there to ensure that everything else that follows is also in this package. Finally the &lt;code&gt;;; blah blah blah.&lt;/code&gt; portion looks like a comment, something to describe functionality with, but nothing to be executed.&lt;/p&gt;

&lt;p&gt;Now in order to see if everything is working correctly let&amp;rsquo;s load this package. Instead of using the REPL from the command line, we are using it directly from our editor, in this case an &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34; target=&#34;_blank&#34;&gt;Emacs&lt;/a&gt; distribution named &lt;a href=&#34;http://spacemacs.org/&#34; target=&#34;_blank&#34;&gt;Spacemacs&lt;/a&gt;. Without going into much detail about Emacs it can be described as a highly configurable editor for pretty much any programming language out there. &lt;a href=&#34;https://common-lisp.net/project/slime/&#34; target=&#34;_blank&#34;&gt;SLIME: The Superior Lisp Interaction Mode for Emacs&lt;/a&gt; ensures that our interaction with the REPL and the various language features go much more smoothly by integrating it with our editor of choice.&lt;/p&gt;

&lt;p&gt;Emacs is incredibly configurable, which is where Spacemacs comes in. It provides a set of curated configurations named layers, that make setting up the configuration for a particular language a breeze. We just enable the &lt;a href=&#34;https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Blang/common-lisp#install&#34; target=&#34;_blank&#34;&gt;common-lisp layer&lt;/a&gt; of Spacemacs in the configuration file, add a small piece to let Emacs know of our Common Lisp distribution (see link), and we are good to go.&lt;/p&gt;

&lt;!-- One really nice feature of Spacemacs is that commands can be executed and discovered by pressing the spacebar as the leader followed by some other combinations (this is where the distribution gets its name). For example, the process of starting SLIME can be done by navigating to a common lisp source file, such as that above, and pressing the keys `space m &#39;` in succession. Note that this requires the use of [vi](https://en.wikipedia.org/wiki/Vi)-mode which is a whole another topic for discussion, but a more emacs like mode with a different leading key also exist. To keep things clear, regardless whichever mode or even emacs distribution one uses, I will try to name the command, and not the key combination whenever possible --&gt;

&lt;p&gt;With everything setup now we can start our treasure hunt a bit more in earnest by starting SLIME. We are greeted by the message &amp;ldquo;Connected. Hack and be merry!&amp;rdquo; as well as a REPL in a window. Lets start to dig around by figuring out what exactly all the elements do. We can use the command &lt;code&gt;slime-describe-symbol&lt;/code&gt; to get some more information about &lt;code&gt;defpackage&lt;/code&gt; and what it does. This brings up some documentation on &lt;code&gt;defpackage&lt;/code&gt;. It shows us that this is a macro, as well as the various options one can use with it. A macro, without going into too much detail, is essentially a way to convert forms into different ones before evaluating them. We can get a bit more info on the workings by calling the command &lt;code&gt;slime-hyperspec-lookup&lt;/code&gt;. This takes us to the &lt;a href=&#34;http://www.lispworks.com/documentation/HyperSpec/Front/&#34; target=&#34;_blank&#34;&gt;Common Lisp Hyperspec&lt;/a&gt; with more detailed docs. The pages for &lt;a href=&#34;http://www.lispworks.com/documentation/HyperSpec/Body/m_defpkg.htm&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;defpackage&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;http://www.lispworks.com/documentation/HyperSpec/Body/m_in_pkg.htm&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;inpackage&lt;/code&gt;&lt;/a&gt; more or less confirm their use is as we expected.&lt;/p&gt;

&lt;p&gt;Now it is time to start writing some new code. We remove the comments and create a function named &lt;code&gt;hello-treasure&lt;/code&gt;, that should just print the text &amp;ldquo;Hello Treasure&amp;rdquo;. We add the following to our file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defun hello-treasure ()
  (print &amp;quot;Hello Treasure!&amp;quot;)
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in place of the comments, and we run the command &lt;code&gt;slime-complile-and-load-file&lt;/code&gt;. Compilation succeeds, but when we aim to call the function  &lt;code&gt;(common-treasure:hello-treasure)&lt;/code&gt; get an error when trying to call the function, saying &amp;ldquo;The symbol &amp;ldquo;HELLO TREASURE&amp;rdquo; is not external to the &amp;ldquo;COMMON TREASURE&amp;rdquo; package.&amp;ldquo;. This due to the fact that we did not declare the function external in the &lt;code&gt;defpackage&lt;/code&gt; package declaration.&lt;/p&gt;

&lt;p&gt;What is really interesting is that, although we have this issue, instead of just failing the SLIME REPL presents us with a number of options. For example we can  &lt;code&gt;0: [Continue] Use symbol anyway.&lt;/code&gt;, &lt;code&gt;1: [Retry] Retry SLIME REPL evaluation request.&lt;/code&gt;, &lt;code&gt;2: [*Abort] Return to SLIME&#39;s top level.&lt;/code&gt;. In this case we can just abort, and modify the package declaration, but it is interesting to be offered all these options.&lt;/p&gt;

&lt;p&gt;By adding &lt;code&gt;(:export :hello-treasure)&lt;/code&gt; to the &lt;code&gt;defpackage&lt;/code&gt; macro, we can do another call and it indeed returns &amp;ldquo;Hello Treasure!&amp;rdquo; in the REPL.&lt;/p&gt;

&lt;p&gt;Now that we got the basics down we would like to have a slightly bigger example in which we make use of an existing library. While digging around for the software languages and libraries of the past is often the matter of some searching, reading, coding and a bit of trial and error. Digging around in the world is process governed by various regulations and laws. This is especially true in cities with long history, where a regular building site can easily unearth archaeological finds.&lt;/p&gt;


&lt;figure&gt;
    
        &lt;img src=&#34;https://www.newresalhaider.com/img/post/2018-06/common-treasure/excavation-city.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Digging in the certain urban areas can easily lead to excavations done before any subsequent work is done. Romano-Celtic temple excavated in London.&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;In particular, there are often a set of regulations that specify whether one can dig in areas of archaeological interests. As an example we use a portion of the rules by the municipality of Utrecht, as described on a &lt;a href=&#34;https://www.utrecht.nl/fileadmin/uploads/documenten/9.digitaalloket/REO/archeologische-waardenkaart-2009.pdf&#34; target=&#34;_blank&#34;&gt;map&lt;/a&gt; of Utrecht and surrounding areas (in Dutch).&lt;/p&gt;

&lt;p&gt;These regulations can be summarized by a number of rules, based on two conditions: the type of area and the size of the area that is to be disturbed.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If the area is of high archeological value, then a permit is required no matter what the size of the area is to be disturbed.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the area is of high archeological expectation, then a permit is required when the size of the area that is to be disturbed is larger than 100m&lt;sup&gt;2&lt;/sup&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the area is of archeological expectation, then a permit is required when the size of the area that is to be disturbed is larger than 1000m&lt;sup&gt;2&lt;/sup&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Such regulations can be encoded into a regular function that returns a true or false to the question &amp;ldquo;Is the a permit required?&amp;rdquo; based on two parameters, the size of the area and the type of the area. However this could be more complicated and harder to maintain if the set of regulations, along with conditions and outcomes, become more complex.&lt;/p&gt;

&lt;p&gt;There are various approaches to deal with this issue. One of these is to encode the facts on which our answer relies into a knowledge base, and have a general mechanism to derive new knowledge from existing facts. This later process is often denoted as inferring or reasoning to derive new knowledge. Such an approach can make it easier to use and maintain such a system.&lt;/p&gt;

&lt;p&gt;For this article we are going to implement such an approach using &lt;a href=&#34;http://lisa.sourceforge.net/&#34; target=&#34;_blank&#34;&gt;LISA&lt;/a&gt;. This is a production rule system, in which the knowledge base is encoded in a set of facts, and rules are uses as a way to derive new knowledge. It is easy to see how such a system would be a good fit for our problem: our domain restrictions are already formulated as a set of rules. It would also allow us to use some existing libraries, to see more of what Common Lisp has to offer.&lt;/p&gt;

&lt;p&gt;To start off, first we need to add a dependency to LISA into our system. One of the files created by cl-project is an &lt;a href=&#34;https://common-lisp.net/project/asdf/?&#34; target=&#34;_blank&#34;&gt;asdf&lt;/a&gt; file that describes how to build the software we are creating. Here we can add the dependency on Lisa, resulting in the following file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#|
  This file is a part of common-treasure project.
|#

(defsystem &amp;quot;common-treasure&amp;quot;
  :version &amp;quot;0.1.0&amp;quot;
  :author &amp;quot;&amp;quot;
  :license &amp;quot;&amp;quot;
  :depends-on (&amp;quot;lisa&amp;quot;) ;; Here we add the dependency on LISA.
  :components ((:module &amp;quot;src&amp;quot;
                :components
                ((:file &amp;quot;common-treasure&amp;quot;))))
  :description &amp;quot;&amp;quot;
  :long-description
  #.(read-file-string
     (subpathname *load-pathname* &amp;quot;README.markdown&amp;quot;))
  :in-order-to ((test-op (test-op &amp;quot;common-treasure-test&amp;quot;))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we just need to make sure the dependencies needed are actually downloaded and available. For this we use &lt;a href=&#34;https://www.quicklisp.org/beta/&#34; target=&#34;_blank&#34;&gt;quicklisp&lt;/a&gt; which is the library manager Common Lisp. By using the command &lt;code&gt;(ql:quickload &amp;quot;common-treasure&amp;quot;)&lt;/code&gt; we can get all the dependencies for our system, which in this case consists of just LISA.&lt;/p&gt;

&lt;p&gt;Now in order to translate our example scenario, we look at some of the examples that are available for LISA. A typical system consists of a knowledge base, in which facts are defined as &lt;a href=&#34;http://www.aiai.ed.ac.uk/~jeff/clos-guide.html&#34; target=&#34;_blank&#34;&gt;Common Lisp Object System (CLOS)&lt;/a&gt; objects and rules to manipulate such instances as the reasoning method.&lt;/p&gt;

&lt;p&gt;CLOS is a way in which Common Lisp can do object-oriented programming, and LISA co-opts this as a way to represent facts in the knowledge base. Without going into detail on object-oriented programming theory, this allows one to, define classes, create instances of those classes and define methods that make use of those classes (see this &lt;a href=&#34;http://www.aiai.ed.ac.uk/~jeff/clos-guide.html&#34; target=&#34;_blank&#34;&gt;nice intro on Common Lisp Object System (CLOS)&lt;/a&gt; for its general use).&lt;/p&gt;

&lt;p&gt;In the context of LISA, these allow us to represent classes of facts, specific instances of facts, and methods that can be used with those facts. For example we can represent the type of facts in our domain with two classes of objects: one that represents &amp;ldquo;area&amp;rdquo; and one that whether &amp;ldquo;a permit is required&amp;rdquo;. In Common Lisp these can be defined with the &lt;code&gt;defclass&lt;/code&gt; macro. So for our example the following would be a call for permission requirement:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defclass permit-required ()
  ()
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case of the area, we need to represent two facts about it: what the archaeological type of it is, and what size of the area is disturbed. Such elements of the classes are described in CLOS using slots. There are many possible options that are available to describe a slot:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:initarg&lt;/code&gt; describes the name of the slot.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:initform&lt;/code&gt; is the default value it is given initially.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:accessor&lt;/code&gt; can be used to define a function for accessing the slot value.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Putting this together gives us the following class for representing the area:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defclass area ()
  ((archeological-type :initarg :archeological-type :initform &amp;quot;&amp;quot; :accessor :archeological-type)
   (size-disturbed :initarg :size-disturbed :initform 0.0 :accessor :size-disturbed)
    ))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we figured out how represent facts, we need to encode the rules of our domain into our system. We can do this with 3 rules that describe what to do in the cases of &lt;code&gt;high archeological value&lt;/code&gt;, &lt;code&gt;high archeological expectation&lt;/code&gt; and &lt;code&gt;archeological expectation&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The rules themselves described with three parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The antecedent, which is the set of conditions that have to be true.&lt;/li&gt;
&lt;li&gt;The arrow sign &lt;code&gt;=&amp;gt;&lt;/code&gt; .&lt;/li&gt;
&lt;li&gt;The consequent, which contains the facts that need to be derived or any actions that we want to perform.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the case of LISA, and in many other rule based definitions, the antecedent and the consequent are also called Left Hand Side (LHS) and Right Hand Side (RHS), as they are respectively on the left and right hand side of the arrow. What exactly can be put into the LHS and RHS is dependent on the language for the rule definitions, but one standard way they are used is in the LHS the conditions are described based on the facts that could be in the knowledge base, and on the RHS facts are added in the knowledge based on the meaning of the rule. For example for one of our rules, if the know the fact that our area is of high archaeological value (LHS), we can derive the fact that we need a permit (RHS).&lt;/p&gt;

&lt;p&gt;Describing our three rules this way in LISA looks as follows, using the &lt;code&gt;defrule&lt;/code&gt; macro:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; If the area is of high archeological value, then a permit is required no matter what the size of the area is to be disturbed.
(defrule high-value () (area (archeological-type &amp;quot;high-value&amp;quot;)) =&amp;gt; (assert ((make-instance &#39;permit-required))))

;; If the area is of high archeological expectation, that a permit is required when the size of the area that is to be disturbed is larger than 100m&amp;lt;sup&amp;gt;2&amp;lt;/sup&amp;gt;.
(defrule high-expectation () (area (archeological-type &amp;quot;high-expectation&amp;quot;) (&amp;gt; size-disturbed 100))  =&amp;gt; (assert ((make-instance &#39;permit-required))))

;; If the area if of archeological expectation, that a permit is required when the size of the area that is to be disturbed is larger than 1000m&amp;lt;sup&amp;gt;2&amp;lt;/sup&amp;gt;.
(defrule expectation () (area (archeological-type &amp;quot;expectation&amp;quot;) (&amp;gt; size-disturbed 1000))  =&amp;gt; (assert ((make-instance &#39;permit-required))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rules are reasonably straightforward, in that they require the condition matching in the knowledge base, before they assert an instance of the &lt;code&gt;permit-required&lt;/code&gt; fact into the knowledge base.&lt;/p&gt;

&lt;p&gt;These together already describe the domain, but for this article we also show how things work with two examples. In one scenario we assert that we have an area with &lt;code&gt;high-value&lt;/code&gt; archaeological type and a to be disturbed are with the size of 2000m&lt;sup&gt;2&lt;/sup&gt;. In this case we would need a permit, due to our &lt;code&gt;high-value&lt;/code&gt; rule. In the second scenario, the area is of &lt;code&gt;high-expectation&lt;/code&gt; but the size of the area disturbed is only 10m&lt;sup&gt;2&lt;/sup&gt;. In this case none our rules will fire, and no &lt;code&gt;permit-required&lt;/code&gt; fact instance is put into the knowledge base.&lt;/p&gt;

&lt;p&gt;Executing the system is just a matter of adding these facts in the knowledge base and letting the system run. In LISA adding a fact can be done using &lt;code&gt;assert&lt;/code&gt; similarly to what the RHS of the rules are doing. To actually run the system, unsurprisingly, the function &lt;code&gt;run&lt;/code&gt; can be called. To see what facts are in the knowledge base the function &lt;code&gt;facts&lt;/code&gt; prints them out for us to see. To tie things together, we make sure that the knowledge base is reset before we execute anything using &lt;code&gt;reset&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Below is the full example implementation that we put together:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defpackage common-treasure
  )

(in-package :lisa-user)

(reset)

(defclass area ()
  ((archeological-type :initarg :archeological-type :initform &amp;quot;&amp;quot; :accessor :archeological-type)
   (size-disturbed :initarg :size-disturbed :initform 0.0 :accessor :size-disturbed)
    ))

(defclass permit-required ()
  ()
)

;; If the area is of high archeological value, then a permit is required no matter what the size of the area is to be disturbed.
(defrule high-value () (area (archeological-type &amp;quot;high-value&amp;quot;)) =&amp;gt; (assert ((make-instance &#39;permit-required))))

;; If the area is of high archeological expectation, that a permit is required when the size of the area that is to be disturbed is larger than 100m&amp;lt;sup&amp;gt;2&amp;lt;/sup&amp;gt;.
(defrule high-expectation () (area (archeological-type &amp;quot;high-expectation&amp;quot;) (&amp;gt; size-disturbed 100))  =&amp;gt; (assert ((make-instance &#39;permit-required))))

;; If the area if of archeological expectation, that a permit is required when the size of the area that is to be disturbed is larger than 1000m&amp;lt;sup&amp;gt;2&amp;lt;/sup&amp;gt;.
(defrule expectation () (area (archeological-type &amp;quot;expectation&amp;quot;) (&amp;gt; size-disturbed 1000))  =&amp;gt; (assert ((make-instance &#39;permit-required))))

;;Test fact 1
;; (assert ((make-instance &#39;area :archeological-type &amp;quot;high-value&amp;quot; :size-disturbed 2000)))

;;Test fact 2
(assert ((make-instance &#39;area :archeological-type &amp;quot;high-expectation&amp;quot; :size-disturbed 10)))

(facts)

(run)

(facts)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that here the &lt;code&gt;fact 1&lt;/code&gt; is commented out, to test the assert of &lt;code&gt;fact 2&lt;/code&gt;, so that running the other scenario is just a matter of commenting and un-commenting the relevant lines.&lt;/p&gt;

&lt;p&gt;For the first scenario, with fact 1, the output of our initial program is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[package common-treasure]#&amp;lt;INITIAL-FACT ; id 0 {1002669853}&amp;gt;
#&amp;lt;AREA ; id 1 {1002745373}&amp;gt;
For a total of 2 facts.
#&amp;lt;INITIAL-FACT ; id 0 {1002669853}&amp;gt;
#&amp;lt;AREA ; id 1 {1002745373}&amp;gt;
#&amp;lt;PERMIT-REQUIRED ; id 2 {100283A363}&amp;gt;
For a total of 3 facts.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we print out our facts twice, once before the run and once after, but it shows that now the permit requirement was derived.&lt;/p&gt;

&lt;p&gt;For the case of using &lt;code&gt;fact 2&lt;/code&gt; , we get the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[package common-treasure].#&amp;lt;INITIAL-FACT ; id 0 {1004D40AB3}&amp;gt;
#&amp;lt;AREA ; id 1 {10020107C3}&amp;gt;
For a total of 2 facts.
#&amp;lt;INITIAL-FACT ; id 0 {1004D40AB3}&amp;gt;
#&amp;lt;AREA ; id 1 {10020107C3}&amp;gt;
For a total of 2 facts.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This shows that our fact base did not change due to our running the reasoning system.&lt;/p&gt;

&lt;p&gt;So there we have it, a bit of a peek of what can be done with Common Lisp. I have to say the language and its various features are quite a bit daunting, as I feel I have only scratched the surface of what is possible, with both interacting with the language as well as with A.I. tools such as LISA. That said digging into the language and seeing how it can handle a small, but also relevant scenario, felt like a worthwhile journey, and that is an experience always worth treasuring.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Spec-stacular Spider-Man</title>
      <link>https://www.newresalhaider.com/post/spec-stacular-spider-man/</link>
      <pubDate>Sun, 29 Apr 2018 00:00:00 +0200</pubDate>
      
      <guid>https://www.newresalhaider.com/post/spec-stacular-spider-man/</guid>
      <description>&lt;p&gt;Spider-Man is one of the most iconic heroes of the Marvel universe. Created by Stan Lee and Steve Ditko, Spider-Man is a regular teenager named Peter Parker, who due to being bitten by a radio-active spider, gains abilities such as the proportional strength of a spider, wall crawling and a spider sense to detect upcoming danger. One of the biggest draws of Spider-Man that although he is a superhero and fought various villains from cosmic beings to petty criminals, he also had to deal with regular everyday problems, such as money issues, school life and the pressure of a job.&lt;/p&gt;


&lt;figure&gt;
    
        &lt;img src=&#34;https://www.newresalhaider.com/img/post/2018-04/spec-stacular-spider-man/spectacular-spider-man.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;The Spectacular Spider-Man © Marvel Entertainment&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;In software there are also everyday problems which one has to tackle before one can defeat the villains of the domain at hand. One of these everyday problems is the issue of data validation. Data validation is the process of ensuring that the elements of the data are correct. This process has to be done in pretty much all domains when working with actual data. Consider the financial domain where a financial product can only be made available if the right requirements are fulfilled in the request. If the request is not written correctly then the request needs to be denied. In the legal and regulatory domains certain information that is required for a law must be fulfilled, otherwise costly corrections or fines can follow. Another good example is the clinical domain, where the a patients data needs to be transferred to an application. Here is it essential that this data fulfills the requirement for requesting a clinical procedure or a medication, as any mistake can lead to huge negative impact on the health of the patient.&lt;/p&gt;

&lt;p&gt;One relatively recent tool that can be used to solve this problem is the &lt;a href=&#34;https://clojure.org/guides/spec&#34; target=&#34;_blank&#34;&gt;clojure.spec&lt;/a&gt; library in the Clojure programming language. In this article we aim to explain, alongside Spider-Man, how these specs can be used to tackle the data validation problem in a spectacular way. As this library relies on the Clojure language some knowledge of Clojure is needed. In order to make this article understandable to those without such prior expertise we introduce some aspects of Clojure. In particular we focus on two features of it: the way information (data) is represented and the fact that it is a Lisp.&lt;/p&gt;

&lt;p&gt;In Clojure data is represented with relatively few elements that are combined together. Take for example a scenario where we want to create a profile of Spider-Man, as taken from the Marvel wiki entry on &lt;a href=&#34;http://marvel.com/universe/Spider-Man_(Peter_Parker)&#34; target=&#34;_blank&#34;&gt;Spider-Man&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The full name of Spider-Man can be represented in text form as a string. Like in many other languages the text is placed in between quotation marks.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;&amp;quot;Peter Benjamin Parker&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the numbers to represent his relative power in the Marvel universe, we use natural numbers (we leave the concepts and issues surrounding very large or floating point numbers out in this article). In case of Spider-Man his durability is 5:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course having just a value of the name and the durability of Spider-Man just floating around makes the representation somewhat incomplete, as they are not attached to the concepts of &amp;ldquo;name&amp;rdquo; or &amp;ldquo;durability&amp;rdquo;. Just like how Spider-Man needs buildings to sling off of, we need a representation that links the values with what they represent. In Clojure, keywords are often used for this purpose.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;:real-name
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;:spider-man-spec.core/name
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;::durability
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Keywords are symbolic identifiers. Think of them as symbols, much like one would use a string, but with some special powers attached. They are text prefaced by &amp;ldquo;:&amp;ldquo;, as it can be seen in the keyword &lt;code&gt;:real-name&lt;/code&gt;. They have the ability to be namespace-qualified, such as &lt;code&gt;:spider-man-spec.core/name&lt;/code&gt; which indicates that this is the keyword in the &lt;code&gt;spider-man-spec.core&lt;/code&gt; namespace. Namespaces are what allows us to modularize our data and code, by grouping them under together a single identifier. In our case this is &lt;code&gt;spider-man-spec.core&lt;/code&gt;. This namespacing ensures that our definition of the concepts of &amp;ldquo;name&amp;rdquo;, &amp;ldquo;real-name&amp;rdquo;, &amp;ldquo;durability&amp;rdquo;, etc. can remain distinct from any other use of similar concepts. Finally, when writing internally to the library which uses the namespace, or when aliasing to it, we can just shorten the keyword with &amp;ldquo;::&amp;ldquo;, such as in &lt;code&gt;::durability&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Keywords come with some nice implementation details, such as fast equality checks and some other powers we will show in the future. This makes them the preferred keys in data-structures such as maps. And speaking of maps they allow the description of information in key-value pairs, as written between curly braces in the small example below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;  {::name &amp;quot;Spider-Man&amp;quot;
   ::real-name &amp;quot;Peter Benjamin Parker&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The curly backets around the pairs express the keys and values in a map in Clojure. In the above example &lt;code&gt;::name&lt;/code&gt; and &lt;code&gt;::real-name&lt;/code&gt; are the key and value pairs for &lt;code&gt;&amp;quot;Spider-Man&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;Peter Benjamin Parker&amp;quot;&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;Maps are just one of the ways one can describe a collection of elements. You also have sets, collections in which each element is unique. This can be done with a hashtag and some curly brackets &amp;ldquo;#{}&amp;rdquo;. In the example below we list the current and former affiliations of Spider-Man.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;{::current-affiliations #{&amp;quot;Avengers&amp;quot;}
 ::former-affiliations #{&amp;quot;Secret Defenders&amp;quot; &amp;quot;New Fantastic Four&amp;quot; &amp;quot;The Outlaws&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that how sets are used within maps to represent this knowledge. This is actually a common way to represent knowledge in Clojure: you combine all the various data representations directly. This way you can have a list containing maps, with keywords as keys and values that contain maps and strings, where the maps contain numbers, etc. You have these data-structures in pretty much all commonly used programming languages. Where Clojure differs from many is that it does not put (almost any) sugaring or abstraction on top.&lt;/p&gt;


&lt;figure&gt;
    
        &lt;img src=&#34;https://www.newresalhaider.com/img/post/2018-04/spec-stacular-spider-man/spider-man-swinging.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Spider-Man swinging around the city. © Marvel Studios&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Just as Spider-Man is often at his best when he is just being &amp;ldquo;plain old Spidey&amp;rdquo;, having data represented this way has some nice advantages. The biggest is simplicity. Instead of learning to work with specific wrappers, objects, prototypes, etc on top of this data, that can differ between applications and libraries, it is enough to learn how to handle and manipulate maps, list, sets once. This knowledge can be then reused in any domain, and frees up the attention of the programmer to focus on the domain problem, and not the exact way the data was wrapped up in a library.&lt;/p&gt;

&lt;p&gt;This of course also means that a system, such as clojure.spec, that aims at data validation in Clojure, has to handle the above-mentioned style of composition well. But before we get ahead of ourselves lets finish up by providing the profile of Spider Man.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def spider-man-profile
  {::name &amp;quot;Spider-Man&amp;quot;
   ::real-name &amp;quot;Peter Benjamin Parker&amp;quot;
   ::identity ::secret
   ::affiliations
                   {::current-affiliations #{&amp;quot;Avengers&amp;quot;}
                    ::former-affiliations #{&amp;quot;Secret Defenders&amp;quot; &amp;quot;New Fantastic Four&amp;quot; &amp;quot;The Outlaws&amp;quot;}}
   ::power-grid {
                 ::durability 3
                 ::energy 4
                 ::fighting 5
                 ::intelligence 4
                 ::speed 5
                 ::strength 4
                 }
   }
  )


(def vulture-profile
  {::name &amp;quot;Vulture&amp;quot;
   ::real-name &amp;quot;Adrian Toomes&amp;quot;
   ::identity ::publicly-known
   ::affiliations
                   {::current-affiliations {}
                    ::former-affiliations #{&amp;quot;Sinister Twelve&amp;quot; &amp;quot;Sinister Six&amp;quot;}}
   ::power-grid {
                 ::durability 4
                 ::energy 3
                 ::fighting 4
                 ::intelligence 4
                 ::speed 5
                 ::strength 3
                 }
   }
  )

(def spider-man-characters [spider-man-profile vulture-profile])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oh no, our Spider Senses should be tingling. It is Vulture, that has shown up in our list of Spider-Man characters. In addition we just introduced some new elements in our example that need some explanation for readers new to Clojure.&lt;/p&gt;


&lt;figure&gt;
    
        &lt;img src=&#34;https://www.newresalhaider.com/img/post/2018-04/spec-stacular-spider-man/vulture.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Uh oh, Vulture must be up to no good if he shows up here. © Marvel Studios&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;The first is the use of square brackets [], which indicate a list. This is a collection of elements, in this case of &lt;code&gt;spider-man-profile&lt;/code&gt; and &lt;code&gt;vulture-profile&lt;/code&gt;, that unlike a set, can have multiples of the same element.&lt;/p&gt;

&lt;p&gt;The other new type of element we use is the form of using parentheses along side def as in &lt;code&gt;(def spider-man-characters ...)&lt;/code&gt;. Expressions of these type, called symbolic expressions, or s-expressions for short, are a characteristic of the Lisp family of languages to which Clojure belongs to. In a Lisp, parts of the program are either atoms, such as &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;&amp;quot;Peter Benjamin Parker&amp;quot;&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, or an s-expression where the first element between parens is a function and the rest are parameters. For example &lt;code&gt;(+ 1 3)&lt;/code&gt;. While atoms evaluate to themselves, the s-expressions evaluate to a function with the given parameters. In the case of &lt;code&gt;(+ 1 3)&lt;/code&gt; they should evaluate to &lt;code&gt;4&lt;/code&gt;. You can also nest s-expressions, such as &lt;code&gt;(- (+ 1 3) 2)&lt;/code&gt;, which will evaluate to &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You might be thinking, &amp;ldquo;Wait, if everything is either an atom or an s-expression, what kind of villainous things are those strange brackets that one has to use to create a set, list or map!&amp;rdquo;. For all the simplicity in Clojure, it does make use of some syntactical sugar. Lists can be written &lt;code&gt;[spider-man-profile vulture-profile]&lt;/code&gt; as a shorthand for the s-expression &lt;code&gt;(list spider-man-profile vulture-profile)&lt;/code&gt;. Similar functions exist for maps and sets as well.&lt;/p&gt;

&lt;p&gt;Much like Spider-Man, who for all his powers still has to struggle with juggling a school and a job and has to make practical decisions, Clojure has to make them as well. In this case because certain things, such as maps, sets and list are used so often, it uses a shorter syntax for creating them. This does makes the language slightly more complex, but in the author&amp;rsquo;s view, it pays off.&lt;/p&gt;

&lt;p&gt;Another matter of practicality of course is that while we can nest the two profiles directly into a list, we can create variables for them to associate. The &lt;code&gt;def&lt;/code&gt; function does exactly this, and it also ensures they become part of the current namespace. For example, if the current namespace is &lt;code&gt;spider-man-spec.core&lt;/code&gt; then a &lt;code&gt;def&lt;/code&gt; of &lt;code&gt;vulture-profile&lt;/code&gt; can be referred to as &lt;code&gt;spider-man-spec.core/vulture-profile&lt;/code&gt; from other namespaces, and simply &lt;code&gt;vulture-profile&lt;/code&gt; in the current namespace. This allows us to break up the overall data in smaller parts to use.&lt;/p&gt;

&lt;p&gt;Now we finally described the profiles of both Spider-Man and Vulture, but are they correct? The library of clojure.spec uses the notion of a spec for this. A spec is simply a function on a single parameter that returns a truthy value (in most cases a &lt;code&gt;true&lt;/code&gt; if the spec holds, &lt;code&gt;false&lt;/code&gt; if the spec does not hold).&lt;/p&gt;

&lt;p&gt;In essence this allows for many existing functions to be used as specs. For example the already existing function &lt;code&gt;string?&lt;/code&gt; checks whether a particular value is a string or not.&lt;/p&gt;

&lt;p&gt;In order to check whether a value is valid for a particular spec we can use the &lt;code&gt;s/valid?&lt;/code&gt; function. Here the &lt;code&gt;s&lt;/code&gt; stands the namespace of the spec library &lt;code&gt;clojure.spec.alpha&lt;/code&gt;, so by calling &lt;code&gt;s/valid?&lt;/code&gt; we are calling the &lt;code&gt;valid?&lt;/code&gt; function of this particular namespace.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(s/valid? string? &amp;quot;Spider-Man&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above function call will checking if &lt;code&gt;&amp;quot;Spider-Man&amp;quot;&lt;/code&gt; is indeed a string, and return &lt;code&gt;true&lt;/code&gt; if it is. On the other hand if we check whether a number is valid for this spec, using &lt;code&gt;(s/valid? string? 6)&lt;/code&gt; we instead get &lt;code&gt;false&lt;/code&gt; returned.&lt;/p&gt;

&lt;p&gt;Another way to use a spec, is to explain why a value is wrong. For example, we can call the function &lt;code&gt;explain-data&lt;/code&gt; on with the spec and an incorrect value, to get a map back with an explanation. The function call:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(s/explain-data string? 6)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would result in the map:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;{:val 6 :predicate :clojure.spec.alpha/unknown}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the above example clearly shows the value on which the spec has failed, but it denotes the predicate as unknown with &lt;code&gt;:clojure.spec.alpha/unknown&lt;/code&gt;. The solution to this is to provide a name for the spec, which the system can use to pin point if things fail. We can register any spec using the function &lt;code&gt;s/def&lt;/code&gt;. For example the functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(s/def ::name string?)

(s/def ::real-name string?)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will register the two specs under the keys &lt;code&gt;:name&lt;/code&gt; and &lt;code&gt;:real-name&lt;/code&gt; in the current namespace, i.e.: under &lt;code&gt;spider-man-spec.core/name&lt;/code&gt; and &lt;code&gt;spider-man-spec.core/name&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;Now if we would aim to explain why the spec &lt;code&gt;:real-name&lt;/code&gt;  does not allow the value &lt;code&gt;6&lt;/code&gt;, it would return the explanation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;{:val 6 :predicate :spider-man-spec.core/real-name}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where the predicate now identifies the spec that was not fulfilled.&lt;/p&gt;

&lt;p&gt;Specs can also be created in other ways. For example a set of values indicating the correct values can be used as a spec.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(s/def ::identity #{::secret ::publicly-known})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code defines a spec for identity as having two possible values: either &lt;code&gt;::secret&lt;/code&gt; or &lt;code&gt;::publicly-known&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Specs can also be defined for collections as well. The specs for current- and former affiliations:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(s/def ::current-affilications (s/coll-of string? :kind set?))

(s/def ::former-affilications (s/coll-of string? :kind set?))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These specs describe that that both current- and former have to be sets of strings. The affiliations part of a profile is actually map containing both current- and former affiliations. This is defined as the spec:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(s/def ::affiliations (s/keys :req [::current-affiliations] :opt [::former-affiliations]) )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which makes it requirement for affiliations to contain current-affiliations, but any former affiliations are optional.&lt;/p&gt;

&lt;p&gt;For checking whether Spider-Man has a valid profile we can use the &lt;code&gt;s/valid?&lt;/code&gt; function again. We use the following code to do just that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;    (let [spider-man-affiliations (:spider-man-spec.core/affiliations spider-man-profile)]
      (s/valid? :spider-man-spec.core/affiliations spider-man-affiliations))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;let&lt;/code&gt; form is new here, but what it essentially does is deconstructing the while &lt;code&gt;spider-man-profile&lt;/code&gt; and associating its affiliations temporarily the &lt;code&gt;spider-man-affiliations&lt;/code&gt;. This allows us to use a shorthand when calling functions, instead of writing out everything in a single line.&lt;/p&gt;

&lt;p&gt;While this value is also valid according to the spec, as the spec and the value we are checking gets more complex, it could also be useful to gather the exact value that has passed the spec. In such cases we can use &lt;code&gt;s/conform&lt;/code&gt; to gather these. The call:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(s/conform :spider-man-spec.core/affiliations spider-man-affiliations)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Returns the map:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;#:spider-man-spec.core{:current-affiliations #{&amp;quot;Avengers&amp;quot;}, :former-affiliations #{&amp;quot;The Outlaws&amp;quot; &amp;quot;Secret Defenders&amp;quot; &amp;quot;New Fantastic Four&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this is a namespaced map, which is a feature that allows us to refer to the keywords inside a map more efficiently, instead of writing them all out in each case.&lt;/p&gt;

&lt;p&gt;The final aspect of each profile, the power grid, is also something that can be given a spec. Each of the powers can only take a whole number value from 1 until 7. We can specify this with the follow spec:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(s/def ::power-value (s/and pos-int? #(&amp;gt;= % 1) #(&amp;lt;= % 7)))

(s/def ::durability ::power-value )
(s/def ::energy ::power-value )
(s/def ::fighting ::power-value )
(s/def ::intelligence ::power-value )
(s/def ::speed ::power-value )
(s/def ::strength ::power-value )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we use the function &lt;code&gt;s/and&lt;/code&gt; to combine three specs: that the value should be a positive integer, greater than or equal to 1 and less or equal to 7. Such a combined spec can then be (re-)used like any other.&lt;/p&gt;

&lt;p&gt;We can combine all the previous specs together to specify a profile:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(s/def ::profile (s/keys :req [::name ::real-name ::identity ::affiliations ::power-grid] ) )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For this spec, both Spider-Man and Vulture are valid profiles. However, this is a problem, as it does not allow us to differentiate between a hero and a villain. Of course we do not want to get Vulture get into the same places as Spider-Man can. We must fight him, much like Spider-Man, but in our own way: by creating a spec for which the Spider-Man profile is a valid value, but not that of Vulture.&lt;/p&gt;


&lt;figure&gt;
    
        &lt;img src=&#34;https://www.newresalhaider.com/img/post/2018-04/spec-stacular-spider-man/spider-man-vs-vulture.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Spider-Man vs Vulture © Marvel Entertainment&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;While we can make a separate requirement that only persons with the name &amp;ldquo;Spider-Man&amp;rdquo; can fulfill our new &amp;ldquo;hero-spec&amp;rdquo; this might be too restrictive. Instead we are going to spec an Avenger profile, so Spider-Man and all his friends can join in, while villains such as Vulture are kept out.&lt;/p&gt;

&lt;p&gt;The requirement for an Avenger in our system, is that any-one with the current affiliation of &lt;code&gt;&amp;quot;Avengers&amp;quot;&lt;/code&gt; is an avenger. We can describe this requirement as a spec, using a function defined for this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(defn is-avenger? [profile]
  (contains? (::current-affiliations (::affiliations profile) ) &amp;quot;Avengers&amp;quot;)
  )

(s/def ::avenger-profile (s/and ::profile is-avenger? ) )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can check whether a profile is a valid Avenger, which will be true for Spider-Man but not for Vulture. Finally, we can get rid of this villain that showed up in our tutorial. In addition, this spec will also make sure that all current members of the Avengers be valid, so Spider-Man can fight freely alongside of them.&lt;/p&gt;


&lt;figure&gt;
    
        &lt;img src=&#34;https://www.newresalhaider.com/img/post/2018-04/spec-stacular-spider-man/spider-man-avengers.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Our spec answers the question posed in this cover: Spider-Man is indeed an Avenger © Marvel Entertainment&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;So there we have it, a brief look at using the spec library to validate data. There are many things that I have not touched, such as the ability to generate values based on the Spec, other ways to compose a spec, etc.&lt;/p&gt;

&lt;p&gt;Nonetheless I hope this article gives a solid introduction, and maybe an interest to using the spec library, even if one does not have a Clojure or even a heavy programming background. The source code snippets are available at: &lt;a href=&#34;https://github.com/newres/spider-man-spec&#34; target=&#34;_blank&#34;&gt;Spider-Man-Spec&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you have a data validation problem, by all means take a swing at it with the Spec library. I am convinced that the results you will get will be nothing short of spectacular.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Art of Choosing a Programming Language</title>
      <link>https://www.newresalhaider.com/post/art-of-choosing-language/</link>
      <pubDate>Sun, 18 Mar 2018 00:00:00 +0100</pubDate>
      
      <guid>https://www.newresalhaider.com/post/art-of-choosing-language/</guid>
      <description>

&lt;p&gt;Programmers, like professionals in other fields, are passionate about their tools. One of the main elements in the toolbox of coders are programming languages. They allow their users to express solutions through code to tackle a large variety of problems in many domains.&lt;/p&gt;

&lt;p&gt;Programming is also an art, as described in the article by Donald Knuth titled &lt;a href=&#34;http://www.paulgraham.com/knuth.html&#34; target=&#34;_blank&#34;&gt;Computer Programming as an Art&lt;/a&gt; and in certain aspects of programming languages can be seen as art styles.&lt;/p&gt;

&lt;p&gt;As can be expected with many things that people are passionate about, whether viewed as a tool or an art style, coders can bond or argue about programming languages. Like philosophers of old, these discussions can go quite into depth, but to the outsider the arguments made or the sentiments behind them can be quite opaque.&lt;/p&gt;


&lt;figure&gt;
    
        &lt;img src=&#34;https://www.newresalhaider.com/img/post/2018-03/art-of-choosing-language/schoolofathens.jpg&#34; alt=&#34;School of Athens by Raphael&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;If programming languages existed back then, I am sure they would be a hotly argued topic.&lt;/h4&gt;
        &lt;p&gt;
        School of Athens by Raphael
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Here I hope to shed some light to the casual observer on what makes programmers passionate about these languages and why some prefer one over the other. Such analysis can be quite subjective, and very much dependent on the writers experiences and preferences, but I will try my best to give an impartial overview.&lt;/p&gt;

&lt;p&gt;In theory many general purpose programming languages are capable of doing the same things. The most commonly used programming languages are Turing complete, meaning that they can all simulate the workings of any Turing machine. Without getting into the full description of what a Turing machine is, for the reader unfamiliar with the concept, this means that any of the languages can express programs for similar tasks.&lt;/p&gt;

&lt;p&gt;There are thousands of programming languages. Some older, and going back to the 50s, 60s and 70s and with considerable use still. Others have been released as recently as the last 10 years, and have gained considerable following. Given as I have mentioned that theoretically all these languages can do the same things, one could wonder why new languages are designed.&lt;/p&gt;

&lt;h2 id=&#34;history&#34;&gt;History&lt;/h2&gt;

&lt;p&gt;Historically, the original computers were instructed by a pure machine language, for example 0s and 1s. Writing programs this way can be tedious and error prone, and the results code can be very difficult to read. This is one of reasons why assembly languages were created. These are languages that are still very much tied into the instruction set of a particular machine, but in a more human readable form, where symbolic names are given for machine instructions. These would be then translated to the pure machine language, to instruct the machine.&lt;/p&gt;

&lt;p&gt;While reading and writing programs becomes easier this way, using assembly languages still has disadvantages. First, these languages are still very much tied to the hardware. Different instruction architectures can mean that a program for the same goal would have to be written differently for each architecture. Second, for many the instructions that one has to write this way are still very low level. The argument is made that with a better set of abstractions over assembly, programs can be written in a better way. A program written with such abstractions could be translated, compiled, to the required machine code specific for the required architecture.&lt;/p&gt;

&lt;p&gt;The question of which abstractions need to be utilized is at the heart of why there are so many different programming languages. People have different ideas on what these abstractions might be, what the benefits and drawbacks of applying them are. This is at the heart of why people design and use newer programming languages. In the following sections we go through some of the aspects on these abstractions.&lt;/p&gt;


&lt;figure&gt;
    
        &lt;img src=&#34;https://www.newresalhaider.com/img/post/2018-03/art-of-choosing-language/pyramids.jpg&#34; alt=&#34;The Giza Pyramids © Robbster1983&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Much like with ancients wonders of next to a modern city, with programming languages old also gives rise to the new, and often co-exists with it .&lt;/h4&gt;
        &lt;p&gt;
        The Giza Pyramids © Robbster1983
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;h2 id=&#34;paradigms-and-style&#34;&gt;Paradigms and Style&lt;/h2&gt;

&lt;p&gt;As mentioned before, there are different opinions on how programs could be constructed. There are various subjects about on which people have opinions about: how the code is organized and how it is executed, among other elements. This is very much similar to how art styles function. For example the same subject can be painted in two differing styles.&lt;/p&gt;


&lt;figure&gt;
    
        &lt;img src=&#34;https://www.newresalhaider.com/img/post/2018-03/art-of-choosing-language/last-supper-da-vinci.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;The Last Supper (Leonardo da Vinci) one of the most famous Renaissance style paintings.&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;figure&gt;
    
        &lt;img src=&#34;https://www.newresalhaider.com/img/post/2018-03/art-of-choosing-language/last-supper-tintoretto.jpg&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;The Last Supper (Tintoretto) depicts the same subject but in a Mannerist, proto-Baroque style.&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Programming languages can be be classified on the different styles, &lt;em&gt;programming paradigms&lt;/em&gt; based on the common elements in the approaches.  Some paradigms include:&lt;/p&gt;

&lt;h3 id=&#34;imperative&#34;&gt;Imperative&lt;/h3&gt;

&lt;p&gt;Imperative code can be seen as a set of commands for the computer to perform. This type of paradigm matches very strongly with how computer hardware is working, as nearly all computer hardware is designed the execute machine language, which is in itself is written in imperative style.&lt;/p&gt;

&lt;h3 id=&#34;procedural&#34;&gt;Procedural&lt;/h3&gt;

&lt;p&gt;One of the ways one can structure a program is to group together a series of commands. These groups, &lt;em&gt;procedures&lt;/em&gt;, can then be called, used or reused as a single entity.&lt;/p&gt;

&lt;h3 id=&#34;object-oriented&#34;&gt;Object-Oriented&lt;/h3&gt;

&lt;p&gt;Object oriented code uses the notion of &lt;em&gt;objects&lt;/em&gt; to organize code. An object is an encapsulation of related state and behavior. For example, consider a software that needs to represent a vehicle. The elements of the state that describe the object, such as &lt;em&gt;colour&lt;/em&gt; and &lt;em&gt;make&lt;/em&gt;, are called attributes.  Various functionality related to the object, such as calculating the price of the car, are called methods. These concepts allow reuse, as the objects for a car and a motorcycle can share functionality.&lt;/p&gt;

&lt;h3 id=&#34;declarative&#34;&gt;Declarative&lt;/h3&gt;

&lt;p&gt;In declarative programming, one describes, or more aptly declares what the problem is as opposed to detailing the steps on how to solve it. This contrasts with imperative programming, where one gives the instructions on how to solve it directly.&lt;/p&gt;

&lt;h3 id=&#34;functional&#34;&gt;Functional&lt;/h3&gt;

&lt;p&gt;Functional programming is one form of declarative programming where programs are constructed using &lt;em&gt;functions&lt;/em&gt;, which are analogous and inspired by to mathematical functions. The intention is that these functions are ideally side effect free: their output is dependent solely on their input. This can make code easier to understand and allows for easier use of code written this way.&lt;/p&gt;

&lt;h3 id=&#34;logic&#34;&gt;Logic&lt;/h3&gt;

&lt;p&gt;The logic paradigm is based around expressing code as a set of logical axioms. These axioms can then be used as a from of knowledge base to derive new knowledge and query. The programs themselves then can be posed as a query in this system. For example, if the knowledge is defined with the axioms &amp;ldquo;Tweety is a bird&amp;rdquo; and &amp;ldquo;Birds are animals&amp;rdquo;, the system should be able to answer the queries: &amp;ldquo;Is Tweety and animal?&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;A language can focus on supporting a particular paradigm heavily or have a strong preference for it. For example &lt;a href=&#34;https://www.haskell.org/&#34; target=&#34;_blank&#34;&gt;Haskell&lt;/a&gt; or &lt;a href=&#34;https://clojure.org/&#34; target=&#34;_blank&#34;&gt;Clojure&lt;/a&gt; lean quite heavily on the functional paradigm, while &lt;a href=&#34;http://www.swi-prolog.org/&#34; target=&#34;_blank&#34;&gt;Prolog&lt;/a&gt; is one of the main logic programming languages. Others, provide an explicit merge of various methodologies, such as &lt;a href=&#34;https://www.scala-lang.org/&#34; target=&#34;_blank&#34;&gt;Scala&lt;/a&gt; that combines elements of object orientation and functional programming.&lt;/p&gt;

&lt;p&gt;Preference for a particular language can go beyond the programming paradigms used. Syntax, the structure of how code is written, can matter quite a bit for person&amp;rsquo;s view on a particular language. For example &lt;a href=&#34;https://www.python.org/&#34; target=&#34;_blank&#34;&gt;Python&lt;/a&gt; uses indentation for managing the control flow of the code, as opposed to symbols in other languages.&lt;/p&gt;

&lt;p&gt;Such preference can go even beyond the actual code itself to the tools one uses to write. While any text editor for editing text can often suffice, people can have differing expectations with regards to integrated development environments (IDEs) or other tools to edit and analyze the code. The lack or existence of specific tooling can also be a factor when deciding between languages.&lt;/p&gt;

&lt;h2 id=&#34;available-code-and-libraries&#34;&gt;Available Code and Libraries&lt;/h2&gt;

&lt;p&gt;Most coding is done with a particular purpose in mind, and it is rarely the case that the programmer can build everything from the ground up for such a task. In order to build interesting programs, one has to utilize existing knowledge, much like someone would utilize knowledge in a library to come to new insights.&lt;/p&gt;

&lt;figure&gt;
  &lt;img src=&#34;https://www.newresalhaider.com/img/post/2018-03/art-of-choosing-language/bibliotheca-alexandrina.jpg&#34;  /&gt;
  &lt;figcaption&gt;
      &lt;h4&gt;The Bibliotheca Alexandrina. Photo © Carsten Whimster licensed under &lt;a href =&#34;https://creativecommons.org/licenses/by/3.0/&#34;&gt; CC BY 3.0 &lt;/a&gt;.&lt;/h4&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Existing code can be used as a foundation from which the program can be built. Roughly speaking existing code comes in three main forms. It is either being part of the language (often called the standard library of the language), some external libraries extending the language for a particular purpose, or an existing code base of the application that one can improve upon.&lt;/p&gt;

&lt;p&gt;The standard library contains various functionality included with the language itself. For example ways of manipulating files, various connection protocols, support for certain file formats, etc. Of course it is very much helpful if particular support for a certain feature that aims to use is already available with the language itself. This means less code to write and connect. On the other hand there is also some tension with regards to including too many features in the standard library, especially if certain parts of it become outdated, which enlarges the language and makes it more unwieldy.&lt;/p&gt;

&lt;p&gt;The external libraries that one can use in a language can also influence the choice of a language. Certain languages have a lot of library support for specific tasks. For example &lt;a href=&#34;https://www.python.org/&#34; target=&#34;_blank&#34;&gt;Python&lt;/a&gt; has a large and active following in the Data Science community. Other languages have a lot of support for many different tasks simply due their age and user base such as &lt;a href=&#34;https://www.java.com/en/&#34; target=&#34;_blank&#34;&gt;Java&lt;/a&gt;. By using libraries one does not need to implement certain features from scratch but can reuse existing work and focus on their specific problem at hand.&lt;/p&gt;

&lt;p&gt;Finally, not all development starts from scratch, often one has to make additions or improvement to an existing program, in which case the choice of the language has already been made. While a rewrite of the code can often be tempting, linking between two code programming languages is not always trivial. It is often a good idea to continue with an existing language.&lt;/p&gt;

&lt;p&gt;There are some exceptions to this as some languages have been designed with the ground up to inter-operate with other languages. A good example of this is &lt;a href=&#34;https://clojure.org/&#34; target=&#34;_blank&#34;&gt;Clojure&lt;/a&gt; has great interop with &lt;a href=&#34;https://www.java.com/en/&#34; target=&#34;_blank&#34;&gt;Java&lt;/a&gt; and/or &lt;a href=&#34;https://en.wikipedia.org/wiki/JavaScript&#34; target=&#34;_blank&#34;&gt;JavaScript&lt;/a&gt;. This allows it to leverage existing libraries already written, and makes it much more attractive to use.&lt;/p&gt;

&lt;h2 id=&#34;existing-knowledge&#34;&gt;Existing Knowledge&lt;/h2&gt;

&lt;p&gt;Writing code is rarely trivial, and neither is learning new programming languages. Although previous experience helps, especially when dealing with languages with known paradigms, due to slight or large differences it can take a while to get used to the new language and libraries. With constantly looming deadlines and pressure to deliver, it can make sense to minimize the work that needs to be done. It is perfectly valid to work with a language that one already knows.&lt;/p&gt;

&lt;h2 id=&#34;curiosity&#34;&gt;Curiosity&lt;/h2&gt;

&lt;p&gt;On the other hand learning a new language, especially in a new paradigm or other innovative features, can be quite interesting. It not only allows for work on existing code written in the new language but it also gives insights in how to program which is beneficial as a programmer in general no matter what language he is using.&lt;/p&gt;

&lt;h2 id=&#34;speed&#34;&gt;Speed&lt;/h2&gt;

&lt;p&gt;As mentioned earlier, commonly used programming languages are abstractions over machine code that can do more of less the same thing computationally. What abstractions are used however can influence the speed of executing the program, as well as the time of translating the code in the programming language to machine code.&lt;/p&gt;

&lt;p&gt;A common abstraction that can influence the speed of executing the program is how memory is managed. During the running of a program certain information needs to be stored. A way to do this is to allocate space in the computers memory, keep it around while needed and remove it afterwards. This latter portion, can be quite difficult to manage manually, as if one does it prematurely the program might crash or have other bugs. Not removing it would fill the memory with garbage, which makes the program use up more and more memory till it crashes.&lt;/p&gt;

&lt;p&gt;A solution to these problems is automatic garbage collection: a way for the computer to automatically manage and clean up memory. While this is a good solution in many cases, this process comes with an overhead, and can be unpredictable when the time and resource consuming cleanup happens. In most cases this overhead is trivial to pay for eliminating a whole suite of potential bugs. However in certain scenarios, such as real-time high performance games, it could be too much to pay.&lt;/p&gt;

&lt;p&gt;The other issue of speed, translating the code from the programming language to machine code, can also be a consideration. Development requires making changes to code and checking whether the changes work. If the process of getting feedback takes a long time, due to these translations, it can destroy a programmers productivity. &lt;a href=&#34;https://golang.org/&#34; target=&#34;_blank&#34;&gt;Golang&lt;/a&gt; is a language that is explicitly designed for fast compilation.&lt;/p&gt;

&lt;h2 id=&#34;safety&#34;&gt;Safety&lt;/h2&gt;

&lt;p&gt;Safety is in many cases the flip side to the speed argument. Certain abstractions cost you in speed but provide you with safety in return. Different languages tend to make different trade-offs with this regard. For example one of the relatively new languages, &lt;a href=&#34;https://www.rust-lang.org/en-US/&#34; target=&#34;_blank&#34;&gt;Rust&lt;/a&gt; aims at focus on zero cost abstractions: abstractions with little to no run-time performance penalty.&lt;/p&gt;

&lt;p&gt;One contentious aspect of safety is the use of type systems. Types allow the coder to specify various categories, such as numbers, persons, cars, etc as well as their requirements to be fulfilled within the context of the program. Types can be checked both statically, before the system is run, or dynamically, during the running of the program. Some people swear by very expressive type systems: where types can specify very detailed features of the things the program wants to represent. This then can be used for checking code for correctness, both before and during the running of a program, as well as documentation. On the other hand type checking is not free: it can make translating the compilation into machine code a much slower process. Some people also consider the writing and checking of types themselves very cumbersome during initial development, where quick iteration can be slowed down by specifying detailed types.&lt;/p&gt;

&lt;p&gt;There is a whole spectrum of possible stances with regards to type systems. For example, certain languages such as &lt;a href=&#34;https://www.haskell.org/&#34; target=&#34;_blank&#34;&gt;Haskell&lt;/a&gt; and &lt;a href=&#34;https://www.idris-lang.org/&#34; target=&#34;_blank&#34;&gt;Idris&lt;/a&gt; are designed from the ground up with very expressive type systems that are statically checked. Others, for example &lt;a href=&#34;https://www.dartlang.org/&#34; target=&#34;_blank&#34;&gt;Dart&lt;/a&gt; which started off as having optional types but adds mandatory types in the latest iteration to help with tooling, take a more balanced approach. &lt;a href=&#34;https://golang.org/&#34; target=&#34;_blank&#34;&gt;Golang&lt;/a&gt; explicitly has a static, but minimalist, type system that allows for fast compilation.  There are also languages, such as &lt;a href=&#34;https://clojure.org/&#34; target=&#34;_blank&#34;&gt;Clojure&lt;/a&gt; that instead of static types, use contract systems to ensure safety at run-time and allow for documentation and testing.&lt;/p&gt;

&lt;h2 id=&#34;deployment&#34;&gt;Deployment&lt;/h2&gt;

&lt;p&gt;While most general purpose programming languages can be made to run in all environments, they are not always available. In certain environments, such as mobile or on the web, only specific languages are supported. For example on Android &lt;a href=&#34;https://www.java.com/en/&#34; target=&#34;_blank&#34;&gt;Java&lt;/a&gt; and &lt;a href=&#34;https://www.java.com/en/&#34; target=&#34;_blank&#34;&gt;Kotlin&lt;/a&gt; are officially supported, while on the web &lt;a href=&#34;https://en.wikipedia.org/wiki/JavaScript&#34; target=&#34;_blank&#34;&gt;JavaScript&lt;/a&gt; is the current Lingua Franca of the web. This means that it can be quite a herculean effort to make other languages work in such environments, and going with the most supported option is easier.&lt;/p&gt;

&lt;p&gt;The way certain languages can get around on this hindrance is by using the more commonly supported language as the target to translate into. For example &lt;a href=&#34;https://clojurescript.org/&#34; target=&#34;_blank&#34;&gt;ClojureScript&lt;/a&gt; compiles into &lt;a href=&#34;https://en.wikipedia.org/wiki/JavaScript&#34; target=&#34;_blank&#34;&gt;JavaScript&lt;/a&gt;. And in some cases, other developers have made the effort to get frameworks up and running that allow the use of a different language, such as the use of &lt;a href=&#34;https://facebook.github.io/react-native/&#34; target=&#34;_blank&#34;&gt;React Native&lt;/a&gt; and &lt;a href=&#34;https://flutter.io/&#34; target=&#34;_blank&#34;&gt;Flutter&lt;/a&gt; that allow the use of &lt;a href=&#34;https://en.wikipedia.org/wiki/JavaScript&#34; target=&#34;_blank&#34;&gt;JavaScript&lt;/a&gt; and &lt;a href=&#34;https://www.dartlang.org/&#34; target=&#34;_blank&#34;&gt;Dart&lt;/a&gt; respectively to develop mobile applications.&lt;/p&gt;

&lt;h2 id=&#34;the-team-and-beyond&#34;&gt;The Team and Beyond&lt;/h2&gt;

&lt;p&gt;One final aspect of choosing a programming language, which can be surprisingly significant, is which language is beneficial to the team, as opposed to an individual developer. Different teams bring different expertise to the table, and while most professionals are often quite willing and able to use a new language if it is most suited to the task at hand, this can still be a cost that might be better spent on developing the application. From an employers perspective it can also often be beneficial to stick to more commonly used languages as it can be easier to find future employees versed in the language used. On the other hand, there are many professionals that would be quite willing to jump on the chance of using the latest programming languages, in which case the choice for a newer or more niche language can be a competitive advantage from a recruiting perspective.&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;I hope this article gave some insight on why programmers pick and argue about programming languages. Despite all the various differences and arguments it is also very important to note, that great software has been written in many different languages, that is both excellent code and solves important problems. And while picking the right tool for the job is an important, it can be just an aspect of the art of solving problems with code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Data Interlinked</title>
      <link>https://www.newresalhaider.com/post/interlinked-data/</link>
      <pubDate>Sun, 18 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.newresalhaider.com/post/interlinked-data/</guid>
      <description>&lt;p&gt;&lt;em&gt;This article contains some very minor spoilers for the Blade Runner 2049 movie. If you have not seen it yet, by all means do, it is really good.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;And blood-black nothingness began to spin&amp;hellip; A system of cells interlinked within cells interlinked within cells interlinked within one stem&amp;hellip; And dreadfully distinct against the dark, a tall white fountain played.&amp;rdquo;&lt;/p&gt;


&lt;figure&gt;
    
        &lt;img src=&#34;https://www.newresalhaider.com/img/post/interlinked-data/palefire.jpg&#34; alt=&#34;Cover of the novel Pale Fire © Berkley Medallion&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Pale Fire by Vladimir Nabokov&lt;/h4&gt;
        &lt;p&gt;
        Cover of the novel Pale Fire © Berkley Medallion
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;The above is a quote from the poem &lt;em&gt;Pale Fire&lt;/em&gt;. It occurs in the novel titled &lt;em&gt;Pale Fire&lt;/em&gt; by Vladimir Nabokov which has been recently used in the movie &lt;em&gt;Blade Runner 2049&lt;/em&gt;. In the movie it was part of the Baseline test, a way to test the emotional response of a Replicant. The reason they undergo this process is because their creators fear that the connections they might make in their lives would give them emotions that would interfere with their intended purpose.&lt;/p&gt;


&lt;figure&gt;
    
        &lt;img src=&#34;https://www.newresalhaider.com/img/post/interlinked-data/bladerunner2049.png&#34; alt=&#34;Poster for the movie © Columbia Pictures&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Blade Runner 2049&lt;/h4&gt;
        &lt;p&gt;
        Poster for the movie © Columbia Pictures
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;In life, such relationships always surround us. They are not just between people, but in our work, in our beliefs, in our art and in the knowledge we represent.&lt;/p&gt;

&lt;p&gt;Suppose we intend to describe the link between the movie &lt;em&gt;Blade Runner&lt;/em&gt; and the book &lt;em&gt;Pale Fire&lt;/em&gt;. We can summarize this information with a number of facts.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Blade Runner is a movie. 
Blade Runner has a character named K.
K is a Replicant.
Replicants must pass a Baseline Test.
Baseline Test is based on the poem Pale Fire.
Pale Fire is written by Vladimir Nabokov.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above facts show that the links that can tie together various pieces of knowledge. One can trace the connections from a simple description of a movie, released in 2017, to the author Vladimir Nabokov, as was intended by the writers of the movie.&lt;/p&gt;

&lt;p&gt;Although the above recitation of facts is easy to follow, from a knowledge representation perspective one can find some issues with it.&lt;/p&gt;

&lt;p&gt;First the description is imprecise. As the &lt;em&gt;Blade Runner&lt;/em&gt; could refer to the newer &lt;em&gt;Blade Runner 2049&lt;/em&gt; movie as opposed to the 1982 original titled &lt;em&gt;Blade Runner&lt;/em&gt;.&lt;/p&gt;


&lt;figure&gt;
    
        &lt;img src=&#34;https://www.newresalhaider.com/img/post/interlinked-data/bladerunner.jpg&#34; alt=&#34;Blade Runner movie poster © 1982 The Ladd Company&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;The first movie titled Blade Runner&lt;/h4&gt;
        &lt;p&gt;
        Blade Runner movie poster © 1982 The Ladd Company
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Second the set of facts is incomplete. The poem &lt;em&gt;Pale Fire&lt;/em&gt; is indeed written by Vladimir Nabokov, but it is presented in the book &lt;em&gt;Pale Fire&lt;/em&gt;, also written by Nabokov as the work of the fictional poet &lt;em&gt;John Shade&lt;/em&gt;. The set of facts here fails to make the explicit distinction between &lt;em&gt;Pale Fire (poem)&lt;/em&gt; and &lt;em&gt;Pale Fire (book)&lt;/em&gt;, and that the poem is contained in the book.&lt;/p&gt;

&lt;p&gt;Third, and perhaps most importantly, the above list of facts relies a lot on the users grasp of the English natural language. For a program, it can be surprisingly difficult to understand the relationships such as &amp;ldquo;is a&amp;rdquo;, &amp;ldquo;is based on&amp;rdquo;, &amp;ldquo;named&amp;rdquo;, etc between the various elements in the text.&lt;/p&gt;

&lt;p&gt;These issues seem somewhat nit-picky, as this information can be derived from the rest of the article. However this means that the knowledge in the summary does not stand on its own. If those facts are detailed without the rest of the article, or if the reader of them is a machine, and not a person that can easily add some context, they might lead them to incorrect or insufficient conclusions. They might get wrong information that the 1982 movie Blade Runner has a character named K, or fail to see the link that poem is contained in the book by the same author. And although in the case of Blade Runner, these issues might seem small, this is different if the knowledge relates to financial, legal or clinical domains. Here, mistakes or omissions can be costly.&lt;/p&gt;

&lt;p&gt;Having a larger list of more detailed facts can help with these issues, but to a certain extent they still remain due to the ambiguity of the natural language. In addition the fact that is often very easy to skip over implicit details. This is especially true for the issue of a computer not being able to make (enough) sense of this information.&lt;/p&gt;

&lt;p&gt;A proposed solution to these issues is &lt;a href=&#34;https://www.w3.org/standards/semanticweb/data&#34; target=&#34;_blank&#34;&gt;Linked Data&lt;/a&gt; and in particular &lt;a href=&#34;https://www.w3.org/standards/techs/rdf#w3c_all&#34; target=&#34;_blank&#34;&gt;Resource Description Framework (RDF)&lt;/a&gt;, with which Linked Data data can be expressed. These technologies allow us to represent the above facts in a more formal and precise way, that can make it both human and machine read- and write-able.&lt;/p&gt;


&lt;figure&gt;
    
        &lt;img src=&#34;https://www.newresalhaider.com/img/post/interlinked-data/rdf.png&#34; alt=&#34;Logo of RDF © W3C&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Resource Description Framework&lt;/h4&gt;
        &lt;p&gt;
        Logo of RDF © W3C
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;One significant feature of RDF is that requires precise naming. Many elements of it are either a &lt;a href=&#34;https://en.wikipedia.org/wiki/International_Resource_Identifier&#34; target=&#34;_blank&#34;&gt;International Resource Identifier (IRI)&lt;/a&gt; or some raw data-types. Good examples of the former are URLs, such as the link to this website: &lt;a href=&#34;http://www.newresalhaider.com&#34; target=&#34;_blank&#34;&gt;http://www.newresalhaider.com&lt;/a&gt; , that allows one to find a web resource. Examples of the later are texts or numbers, such as &amp;ldquo;Blade Runner&amp;rdquo; or 15 respectively.&lt;/p&gt;

&lt;p&gt;The other significant feature of RDF is that most knowledge is represented as a set of facts, where each fact is expressed as subject, predicate object triples. For example the fact &amp;ldquo;Blade Runner is a movie&amp;rdquo; is expressed with the subject &amp;ldquo;Blade Runner&amp;rdquo; the predicate &amp;ldquo;is a&amp;rdquo; and the object &amp;ldquo;movie&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Putting this together in RDF (using the &lt;a href=&#34;https://www.w3.org/TR/turtle/&#34; target=&#34;_blank&#34;&gt;Turtle&lt;/a&gt; notation) you would get a triple such as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Turtle&#34;&gt;&amp;lt;http://www.newresalhaider.com/ontologies/bladerunner/blade-runner&amp;gt; &amp;lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&amp;gt; &amp;lt;http://www.newresalhaider.com/ontologies/bladerunner/movie&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example is an RDF way of saying &amp;ldquo;Blade Runner is a type of movie&amp;rdquo; or alternatively &amp;ldquo;Blade runner is a movie&amp;rdquo;. This type of representation shows us a couple of benefits. First we are now being more precise as each element in the triple can refer to one specific resource, for example Blade Runner or Movie, where there IRI makes sure we do not necessarily confuse the term with anything else. Second this also shows off the fact that you can link to resources from different places: the predicate &amp;ldquo;type&amp;rdquo; is from a completely different domain. This allows us to re-use knowledge that has already been defined. As one can expect saying something is of a &amp;ldquo;type&amp;rdquo;, for example an apple is a type of a fruit, is actually very common. This is one of the main strengths of what makes Linked Data so powerful, one can re-use knowledge already stated.&lt;/p&gt;

&lt;p&gt;Typing out the full IRI each time can be pretty bothersome, and it does not help the readability either. Thankfully we can define a common prefix we use separately, and just write the last part of the IRI in each case. In this case we define a base prefix and we refer to subject and object by &amp;ldquo;&amp;lt;#blade-runner&amp;gt;&amp;rdquo; and &amp;ldquo;&amp;lt;#movie&amp;gt;&amp;rdquo; respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Turtle&#34;&gt;@base &amp;lt;http://www.newresalhaider.com/ontologies/bladerunner&amp;gt; .
&amp;lt;#blade-runner&amp;gt; &amp;lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&amp;gt; &amp;lt;#movie&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can do similar things when linking elements that have been already defined elsewhere. In this case we define a prefix to use as an abbreviation while writing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Turtle&#34;&gt;@base &amp;lt;http://www.newresalhaider.com/ontologies/bladerunner&amp;gt; .
@prefix rdf: &amp;lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&amp;gt; .

&amp;lt;#blade-runner&amp;gt; rdf:type &amp;lt;#movie&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In practice, &amp;ldquo;rdf:type&amp;rdquo; as a predicate is so common that there is an even simpler notation. We can use &amp;lsquo;a&amp;rsquo; as a predicate, which is in line with what we intend to express: &amp;ldquo;Blade Runner is a movie&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The resulting RDF facts look as follows (note that the rdf prefix could be omitted here as the &amp;ldquo;a&amp;rdquo; abbreviation does not make it necessary):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Turtle&#34;&gt;@base &amp;lt;http://www.newresalhaider.com/ontologies/bladerunner&amp;gt; .
@prefix rdf: &amp;lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&amp;gt; .

&amp;lt;#blade-runner&amp;gt; a &amp;lt;#movie&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we aim to write something that is just a text as a subject, say when referring to the title of a movie , we can do that as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Turtle&#34;&gt;@base &amp;lt;http://www.newresalhaider.com/ontologies/bladerunner&amp;gt; .
@prefix rdf: &amp;lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&amp;gt; .

&amp;lt;#blade-runner&amp;gt; a &amp;lt;#movie&amp;gt;.
&amp;lt;#blade-runner&amp;gt; &amp;lt;#title&amp;gt; &amp;quot;Blade Runner 2049&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this way of writing, we can actually rewrite our original set of facts as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Turtle&#34;&gt;@base &amp;lt;http://www.newresalhaider.com/ontologies/bladerunner&amp;gt; .
@prefix rdf: &amp;lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&amp;gt; .
@prefix foaf: &amp;lt;http://xmlns.com/foaf/0.1/&amp;gt; .

&amp;lt;#blade-runner&amp;gt; a &amp;lt;#movie&amp;gt;.
&amp;lt;#blade-runner&amp;gt; &amp;lt;#title&amp;gt; &amp;quot;Blade Runner 2049&amp;quot;.
&amp;lt;#blade-runner&amp;gt; &amp;lt;#has-character&amp;gt; &amp;lt;#K&amp;gt;.
&amp;lt;#K&amp;gt; foaf:name &amp;quot;K&amp;quot;.
&amp;lt;#K&amp;gt; a &amp;lt;#replicant&amp;gt;.
&amp;lt;#replicant&amp;gt; &amp;lt;#must-pass&amp;gt; &amp;lt;#baseline-test&amp;gt;.
&amp;lt;#baseline-test&amp;gt; &amp;lt;#based-on&amp;gt; &amp;lt;#pale-fire-poem&amp;gt;.
&amp;lt;#pale-fire-poem&amp;gt; &amp;lt;#included-in&amp;gt; &amp;lt;#pale-fire-book&amp;gt;.
&amp;lt;#pale-fire-book&amp;gt; &amp;lt;#written-by&amp;gt; &amp;lt;#nabokov&amp;gt;.
&amp;lt;#nabokov&amp;gt; foaf:name &amp;quot;Vladimir Nabokov&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this version we suddenly defined our list of facts in a more formal manner than previously. This makes it much more simpler for machines to understand this set of facts. In fact we actually used the &lt;a href=&#34;https://en.wikipedia.org/wiki/FOAF_(ontology)&#34; target=&#34;_blank&#34;&gt;Friend of a Friend (FOAF) ontology&lt;/a&gt; to use the notion of name that is also used when talking about relationships between people. In fact, one could argue that using an existing movie dataset, such as the &lt;a href=&#34;https://old.datahub.io/dataset/linkedmdb&#34; target=&#34;_blank&#34;&gt;Linked Movie Database&lt;/a&gt; would have been even better, which we will leave as an exercise for the reader.&lt;/p&gt;

&lt;p&gt;Hopefully I could show a glimpse of the possibilities the &lt;a href=&#34;https://www.w3.org/standards/semanticweb/&#34; target=&#34;_blank&#34;&gt;Semantic Web&lt;/a&gt; for which Linked Data forms the basis, with this example. Of course the above is just scratching the surface of what it can be done with RDF, Linked Data. With each addition, our set of facts could grow. One could go beyond a single movie and build a document of poems that are references in movies, or a knowledge base of the Blade Runner franchise. It might be easier than one expects, due to the fact that knowledge, much like people are&amp;hellip;&lt;/p&gt;

&lt;p&gt;Interlinked.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Trouble with Triples</title>
      <link>https://www.newresalhaider.com/post/trouble-with-triples/</link>
      <pubDate>Sun, 28 Jan 2018 00:00:00 +0100</pubDate>
      
      <guid>https://www.newresalhaider.com/post/trouble-with-triples/</guid>
      <description>&lt;p&gt;In the Star Trek episode &amp;ldquo;The Trouble with Tribbles&amp;rdquo; the crew of the starship Enterprise encounters creatures called Tribbles. They are cute, simple creatures of mysterious origin that seem harmless at first but when they multiply the pose a big problem for the ship and the crew.&lt;/p&gt;


&lt;figure&gt;
    
        &lt;img src=&#34;https://www.newresalhaider.com/img/post/trouble-with-triples/tribbles.jpg&#34; alt=&#34;Tribbles © 1967 Paramount Pictures&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Tribbles&lt;/h4&gt;
        &lt;p&gt;
        Tribbles © 1967 Paramount Pictures
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Representing and reasoning with knowledge have surprisingly similar problems. A single fact on its own is a relatively straightforward affair. A fact, such as &lt;strong&gt;&amp;ldquo;Tribbles are cute&amp;rdquo;&lt;/strong&gt; can be represented with only three parts of a triple: a subject &lt;strong&gt;Tribbles&lt;/strong&gt;, a predicate &lt;strong&gt;are&lt;/strong&gt; and an object &lt;strong&gt;cute&lt;/strong&gt;. Things can get quite a bit more difficult when there are more facts/triples: &lt;strong&gt;&amp;ldquo;Tribbles are round&amp;rdquo;&lt;/strong&gt;, &lt;strong&gt;&amp;ldquo;Tribbles are furry&amp;rdquo;&lt;/strong&gt;, &lt;strong&gt;&amp;ldquo;Tribbles originate from Iota Geminorum IV&amp;rdquo;&lt;/strong&gt;, and other millions of facts that one could have about such a species. This is especially true when one takes into the account that the fact that knowledge can be interlinked &lt;strong&gt;&amp;ldquo;Iota Geminorum IV is a planet&amp;rdquo;&lt;/strong&gt;,  &lt;strong&gt;&amp;ldquo;Iota Geminorum IV is also known as Fafniri&amp;rdquo;&lt;/strong&gt;, &lt;strong&gt;&amp;ldquo;Iota Geminorum IV is also known as Tribble Prime&amp;rdquo;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;This makes representing and reasoning with facts a non-trivial process. A system that holds all this knowledge should be able to answer a query such as &lt;strong&gt;&amp;ldquo;Do Tribbles originate from Fafniri?&amp;rdquo;&lt;/strong&gt; with a yes, based on the facts &lt;strong&gt;&amp;ldquo;Tribbles originate from Iota Geminorum IV&amp;rdquo;&lt;/strong&gt;, &lt;strong&gt;&amp;ldquo;Iota Geminorum IV is a planet&amp;rdquo;&lt;/strong&gt; and &lt;strong&gt;&amp;ldquo;Iota Geminorum IV is also known as Fafniri&amp;rdquo;&lt;/strong&gt;, even in the context of millions of other triples.&lt;/p&gt;

&lt;p&gt;Another interesting issue with representing facts is the context of the information. To us the viewers, and initially to the crew of the Enterprise, Tribbles look like harmless and adorable creatures. To the Klingons they are an ecological menace and their mortal enemies. How such &amp;ldquo;knowledge about knowledge&amp;rdquo; is represented and used is often a challenging problem.&lt;/p&gt;

&lt;p&gt;Various technologies have been proposed to deal with the above-mentioned issues. &lt;a href=&#34;https://www.w3.org/standards/semanticweb/&#34; target=&#34;_blank&#34;&gt;The Semantic Web technologies&lt;/a&gt; of &lt;a href=&#34;https://www.w3.org/standards/semanticweb/data&#34; target=&#34;_blank&#34;&gt;Linked Data&lt;/a&gt; and &lt;a href=&#34;https://www.w3.org/standards/techs/owl#w3c_all&#34; target=&#34;_blank&#34;&gt;Ontologies&lt;/a&gt; in particular have been designed around solving many of these problems. Nonetheless there is room for improvement. In the future I hope to be able to explain how these techniques can be utilized and perhaps lessen the pain points that currently surround (the use of) them.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://www.newresalhaider.com/post/introduction/</link>
      <pubDate>Sun, 14 Jan 2018 00:00:00 +0100</pubDate>
      
      <guid>https://www.newresalhaider.com/post/introduction/</guid>
      <description>&lt;p&gt;Welcome to the first post on my blog on which hopefully many will follow. My intention is to write about knowledge representation, reasoning, AI and coding, in an easily digestible but in depth-way.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Legal Regulatory Compliance Within The Financial Domain.</title>
      <link>https://www.newresalhaider.com/project/legal-banking-compliance/</link>
      <pubDate>Sun, 31 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.newresalhaider.com/project/legal-banking-compliance/</guid>
      <description>&lt;p&gt;Regulatory compliance is the goal of an organization to ensure it complies with all the relevant policies, regulations and laws. Failure to comply can have grave consequences for an organization, with huge fines and penalties being imposed. Regulatory pressure has been increasing over the years, with new and more complex regulation being enacted. This is especially true for the financial sector, where in the wake of the financial crisis, new policies and laws where enacted, both internal and external, to prevent a similar crisis happening in the future.&lt;/p&gt;

&lt;p&gt;These new and changing policies and laws give a huge challenge for financial organizations. These issues get compounded by fact that in a global world, internal, national and international regulations create an interwoven set of rules that need to be interpreted and applied on various financial products and services. Ensuring this compliance, is a time and expertise intensive task that often needs to be done manually. Automating these tasks is a huge challenge due to the fact that more traditional techniques are often ill equipped to tackle such an ever changing and complex domain in a way that is transparent to the domain experts and regulators.&lt;/p&gt;

&lt;p&gt;In this project, the goal is to find innovative techniques and solutions to the issue of regulatory compliance in the legal and financial domain.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Smart Industry Software</title>
      <link>https://www.newresalhaider.com/project/innius/</link>
      <pubDate>Sat, 30 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.newresalhaider.com/project/innius/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Ontology Enabled Clinical Software</title>
      <link>https://www.newresalhaider.com/project/clinical-semantics/</link>
      <pubDate>Fri, 29 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.newresalhaider.com/project/clinical-semantics/</guid>
      <description>&lt;p&gt;The time of clinical health professionals is incredibly valuable. Software can alleviate the burden of physicians, nursers and other health experts and allow them to provide better, more effective health care to patients.&lt;/p&gt;

&lt;p&gt;Creating, maintaining and using software in clinical environments is a difficult process. Not only it is paramount that such software needs to be correct, it has to have an understanding of highly domain specific knowledge about clinical processes in order to provide beneficial support to health professionals.&lt;/p&gt;

&lt;p&gt;Semantic Web technologies, in particular anthologies enable better clinical software. Ontologies allow for a formal and explicit way to model knowledge that is understandable for both clinicians and machines alike.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Semantic Aware Software Analysis</title>
      <link>https://www.newresalhaider.com/project/semantic-software-analysis/</link>
      <pubDate>Fri, 22 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.newresalhaider.com/project/semantic-software-analysis/</guid>
      <description>&lt;p&gt;Software bugs and errors have a monumental negative impact on society. Not only can they have huge monetary cost, ranging into billions of dollars annually in the United States alone, but in some cases can even lead to disasters that lead to the loss of life. Preventing such issues from happening requires a large amount of effort in designing and maintaining software.&lt;/p&gt;

&lt;p&gt;However designing and maintaining error free software remains a difficult problem. Not only is software getting more complex, its correct functioning often depends on highly specific domain knowledge of its purpose and its environment. Therefor manually checking the correctness of the software is expensive in both time and available expertise.&lt;/p&gt;

&lt;p&gt;A potential solution that was proposed for this is using machine understandable domain knowledge to help automate software maintenance tasks. Formal ontologies have been proposed and used in various fields to make domain knowledge explicit and usable for both humans and software. In particular during my thesis work, titled &amp;ldquo;An Ontology Based Framework for Specification Mining and Dynamic Program Analysis&amp;rdquo;, the use of ontologies to help understand the working of a running program were successfully explored. In particular it was shown that for a category of bugs, general ontologies such as WordNet, can be used find issues issues from program traces.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Integrating existing large scale medical laboratory data into the semantic web framework</title>
      <link>https://www.newresalhaider.com/publication/medical-data-semantic/</link>
      <pubDate>Mon, 27 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>https://www.newresalhaider.com/publication/medical-data-semantic/</guid>
      <description></description>
    </item>
    
    <item>
      <title>A cross-platform benchmark framework for mobile semantic web reasoning engines</title>
      <link>https://www.newresalhaider.com/publication/benchmark-framework/</link>
      <pubDate>Sun, 19 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>https://www.newresalhaider.com/publication/benchmark-framework/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
